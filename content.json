{"meta":{"title":"么么博客","subtitle":"","description":"程序猿个人随记","author":"Liji","url":"https://liji53.github.io","root":"/"},"pages":[],"posts":[{"title":"LLVM(1)","slug":"LLVM","date":"2022-02-23T02:11:25.000Z","updated":"2022-02-23T02:11:25.000Z","comments":true,"path":"2022/02/23/LLVM/","link":"","permalink":"https://liji53.github.io/2022/02/23/LLVM/","excerpt":"","text":"Clang Static Analyzer 安装和运行最近在利用业余时间学习和研究代码检查，经过比对了几种代码检查工具之后，决定把Clang Static Analyzer作为学习的对象，原因是开源+扩展性。本文我将重点围绕llvm环境搭建，以及实现第一个static analyzer checker 文档资料学习CSA绕不开LLVM、Clang，好在LLVM的文档非常全面，以下全是官方文档链接：LLVM主页面(有提到三者的关系)：https://llvm.org/LLVM介绍(有跟gcc相比的优势)：https://llvm.org/pubs/2008-10-04-ACAT-LLVM-Intro.htmlLLVM向导(有通过LLVM编写新语言的官方教程)：https://llvm.org/docs/tutorial/index.htmlLLVM开发手册(项目结构等资料)：https://llvm.org/doxygen/Clang主页面：https://clang.llvm.org/Clang文档列表：https://clang.llvm.org/docs/index.htmlClang开发手册：https://clang.llvm.org/doxygen/CSA已有检查项：https://clang.llvm.org/docs/analyzer/checkers.htmlCSA开发教程：https://clang-analyzer.llvm.org/checker_dev_manual.html 除了上面的官方文档，还有这些优秀的文章：CSA开发教程(16年写的，可与上面结合看)：https://github.com/haoNoQ/clang-analyzer-guide/releases/download/v0.1/clang-analyzer-guide-v0.1.pdf符号执行(符号执行的原理、面临的挑战)：https://arxiv.org/pdf/1610.00502.pdf VS中构建LLVM参考资料：https://llvm.org/docs/GettingStartedVS.html 环境准备 Visual Studio 2019+，我用2017的试过，反正构建失败了，于是下载了最新的2022版本 Cmake python3.6+ pip install psutil vs打开LLVM项目 下载LLVM项目： 1git clone https://github.com/llvm/llvm-project.git 用cmake生成vs文件，再用vs代开LLVM.sln文件 12cd llvm-projectcmake -S llvm -B build -DLLVM_ENABLE_PROJECTS=&quot;clang&quot; -DLLVM_TARGETS_TO_BUILD=X86 -DCMAKE_INSTALL_PREFIX=&quot;D:\\Program Files (x86)\\llvm&quot; -Thost=x64 项目内容如下： 编译Clang默认是debug模式，编译clang需要很长时间，建议改成release模式编译完之后会在build目录下生成Debug目录，记得加入到环境变量中 添加第一个检查器参考资料：https://github.com/haoNoQ/clang-analyzer-guide/releases/download/v0.1/clang-analyzer-guide-v0.1.pdf由于参考资料是16年的，里面的例子需要修改才能使用 检查目标c++标准中有这么一条：main函数不应该在程序中被调用。目标代码如下： 123456typedef int (*main_t)(int, char**);int main(int argc, char** argv)&#123; main_t foo = main; int exit_code = foo(argc, argv); // actually calls main()! return exit_code;&#125; 常规的方法可能只能查找显式的调用main，而这个例子中通过函数指针隐式调用mian。 添加checker定义打开llvm-project\\clang\\include\\clang\\StaticAnalyzer\\Checkers\\Checkers.td，在alpha.core包中添加下面内容： 12345678910111213def FixedAddressChecker : Checker&lt;&quot;FixedAddr&quot;&gt;, HelpText&lt;&quot;Check for assignment of a fixed address to a pointer&quot;&gt;, Documentation&lt;HasAlphaDocumentation&gt;;/// addeddef MainCallChecker : Checker&lt;&quot;MainCall&quot;&gt;, HelpText&lt;&quot;Check for calls to main&quot;&gt;, Documentation&lt;HasAlphaDocumentation&gt;;def PointerArithChecker : Checker&lt;&quot;PointerArithm&quot;&gt;, HelpText&lt;&quot;Check for pointer arithmetic on locations other than array &quot; &quot;elements&quot;&gt;, Documentation&lt;HasAlphaDocumentation&gt;; 添加源文件在llvm-project\\clang\\lib\\StaticAnalyzer\\Checkers目录下新增文件MainCallChecker.cpp 123456789101112131415161718192021222324252627282930313233343536373839#include &quot;clang/StaticAnalyzer/Checkers/BuiltinCheckerRegistration.h&quot;#include &quot;clang/StaticAnalyzer/Core/BugReporter/BugType.h&quot;#include &quot;clang/StaticAnalyzer/Core/Checker.h&quot;#include &quot;clang/StaticAnalyzer/Core/PathSensitive/CallEvent.h&quot;#include &quot;clang/StaticAnalyzer/Core/PathSensitive/CheckerContext.h&quot;using namespace clang;using namespace clang::ento;namespace &#123;class MainCallChecker : public Checker&lt;check::PreCall&gt; &#123; mutable std::unique_ptr&lt;BugType&gt; BT;public: void checkPreCall(const CallEvent &amp;Call, CheckerContext &amp;C) const;&#125;;&#125;void MainCallChecker::checkPreCall(const CallEvent &amp;Call, CheckerContext &amp;C) const &#123; if (const IdentifierInfo *II = Call.getCalleeIdentifier()) if (II-&gt;isStr(&quot;main&quot;)) &#123; if (!BT) BT.reset(new BugType(this, &quot;Call to main&quot;, &quot;Example checker&quot;)); ExplodedNode *N = C.generateErrorNode(); auto Report = std::make_unique&lt;PathSensitiveBugReport&gt;( *BT, BT-&gt;getDescription(), N); C.emitReport(std::move(Report)); &#125;&#125;void ento::registerMainCallChecker(CheckerManager &amp;Mgr) &#123; Mgr.registerChecker&lt;MainCallChecker&gt;();&#125;bool ento::shouldRegisterMainCallChecker(const CheckerManager &amp;mgr) &#123; return true;&#125; CMakeList中添加编译目标在llvm-project\\clang\\lib\\StaticAnalyzer\\Checkers\\CMakeLists.txt 中添加 123VirtualCallChecker.cppMainCallChecker.cppWebKit/NoUncountedMembersChecker.cpp 测试重新编译之后obj.clangStaticAnalyzerCheckers和clang项目之后，测试 12345PS E:\\code&gt; clang -cc1 -analyze -analyzer-checker=&quot;alpha.core&quot; test.cpp.\\test.cpp:4:18: warning: Call to main [alpha.core.MainCall] int exit_code = foo(argc, argv); // actually calls main ()! ^~~~~~~~~~~~~~~1 warning generated. 可以看到结果，确实正确找到了调用main函数的地方","categories":[],"tags":[]},{"title":"atomic","slug":"atomic","date":"2022-02-04T03:24:16.000Z","updated":"2022-02-04T03:24:16.000Z","comments":true,"path":"2022/02/04/atomic/","link":"","permalink":"https://liji53.github.io/2022/02/04/atomic/","excerpt":"","text":"锁与原子操作在c++11中，其中最大的一个变化就是对多线程的支持，而其中最重要的部分就是引入了原子操作和原子类型。那锁与原子操作有什么联系，区别呢？ 锁的机制与开销现在锁的机制在linux2.5.7之后开始使用futex(fast Userspace mutexes),即内核态和用户态的混合机制。这个机制的主要优势就是在加锁的时候根据mmap共享内存里的futex变量，判断该变量是否有竞争，如果没有竞争则通过原子操作把共享的futex变量改成1，这样就不需要进入内核态，就可以完成加锁了。而如果有竞争则执行系统调用完成处理(wait)。为了帮助理解，下面是我根据pthread_mutex_lock的源代码所写的伪代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int __pthread_mutex_lock (pthread_mutex_t *mutex)&#123; // 普通锁 if (type == PTHREAD_MUTEX_TIMED_NP) &#123; LLL_MUTEX_LOCK(mutex); &#125; // 嵌套锁/递归锁，允许同一个线程多次加锁 elif (type == PTHREAD_MUTEX_RECURSIVE_NP) &#123; // 获取线程id pid_t id = THREAD_GETMEM(THREAD_SELF, tid) // 已经持有锁直接返回 if (mutex-&gt;__data.__owner == id)&#123;return;&#125; // 获取锁 LLL_MUTEX_LOCK(mutex); &#125; // 适应锁，跟自旋锁类似，尝试获取，但过一段时间仍然获取不到，就放弃，并让出CPU elif (type == PTHREAD_MUTEX_ADAPTIVE_NP) &#123; if (LLL_MUTEX_TRYLOCK (mutex) != 0) &#123; // 一直尝试获取 do&#123; // 过一段时间仍然获取不到，则放弃，让出CPU if (++cnt &gt; max_cnt)&#123; LLL_MUTEX_LOCK(mutex); break; &#125; &#125;while(LLL_MUTEX_TRYLOCK(mutex) != 0) &#125; &#125; // PTHREAD_MUTEX_ERRORCHECK_NP 检错锁，不展开 else&#123;......&#125;&#125;void LLL_MUTEX_LOCK()&#123; // CAS原子操作，将0变为1, if（atomic_compare_and_exchange(futex, 0, 1)） &#123; return &#125; /// 有竞争，则阻塞 else&#123; INTERNAL_SYSCALL() &#125;&#125; 从锁的机制来看，如果锁的冲突比较多，则会让线程从用户态切换到内核态，同时由于要让出CPU还存在上下文切换的开销。 C++11的atomic原子类型从上面的实现来看，锁也是通过CAS这些原子操作来实现的，那下面我们结合源码来看看c++11的原子类型是怎么样的，源码来自vs的atomic.h头文件 atomic自定义对象必须是POD我们知道atomic&lt;T&gt;的类型可以是自定义对象，但自定义对象是有限制的 123/// 模板类中，有一个静态检查，表示T的类型必须是POD类型static_assert(is_trivially_copyable_v&lt;_Ty&gt; &amp;&amp; is_copy_constructible_v&lt;_Ty&gt; &amp;&amp; is_move_constructible_v&lt;_Ty&gt; &amp;&amp; is_copy_assignable_v&lt;_Ty&gt; &amp;&amp; is_move_assignable_v&lt;_Ty&gt;,&quot;...&quot;) 原子变量不能拷贝，赋值因为两个原子类型之间的操作不能保证原子化 12atomic(const atomic&amp;) = delete;atomic&amp; operator=(const atomic&amp;) = delete; 非atomic_flag不一定无锁除了atomic_flag,其他任何原子类型不一定是无锁的,具体跟平台相关。在本例中，只要是1,2,4,8大小的数据类型，就是无锁 1234_NODISCARD bool is_lock_free() const volatile noexcept &#123; constexpr bool _Result = sizeof(_Ty) &lt;= 8 &amp;&amp; (sizeof(_Ty) &amp; sizeof(_Ty) - 1) == 0; return _Result; &#125; 如果不是无锁的原子类型，其实底层实现就是mutex1234567struct _Atomic_storage &#123; void store(const _TVal _Value, const memory_order _Order = memory_order_seq_cst) noexcept &#123; _Check_store_memory_order(_Order); _Guard _Lock&#123;_Spinlock&#125;; _Storage = _Value; &#125;&#125;； 原子操作_Atomic_storage&lt;_Ty, 8&gt; 指的是数据结构大小为8 的原子类型，由于平台不一样，这里用的是windows接口：_InterlockedExchange64 1234567891011121314151617struct _Atomic_storage&lt;_Ty, 8&gt;&#123; void store(const _TVal _Value) noexcept &#123; // store with sequential consistency const auto _Mem = _Atomic_address_as&lt;long long&gt;(_Storage); const long long _As_bytes = _Atomic_reinterpret_as&lt;long long&gt;(_Value);#if defined(_M_IX86) _Compiler_barrier(); __iso_volatile_store64(_Mem, _As_bytes); _STD atomic_thread_fence(memory_order_seq_cst);#elif defined(_M_ARM64) _Memory_barrier(); __iso_volatile_store64(_Mem, _As_bytes); _Memory_barrier();#else // ^^^ _M_ARM64 / ARM32, x64 vvv (void) _InterlockedExchange64(_Mem, _As_bytes);#endif // _M_ARM64 &#125;&#125;； 赋值运算符默认std::memory_order_seq_cst12345678910111213_Ty operator=(const _Ty _Value) noexcept &#123; this-&gt;store(_Value); return _Value;&#125;void store(const _TVal _Value, const memory_order _Order) noexcept &#123; // store with given memory order ...... switch (_Order) &#123; ...... case memory_order_seq_cst: store(_Value); return; &#125;&#125; compare_exchange_weak和compare_exchange_strong的区别weak的意思是允许偶然出乎意料的返回(比如实际值和期待值一样的时候却返回了false)，通常它比起strong有更高的性能。可惜在vs的这个版本中并没有实现，与strong版本是一样的。 12345bool compare_exchange_weak(_Ty&amp; _Expected, const _Ty _Desired) volatile noexcept &#123; // we have no weak CAS intrinsics, even on ARM32/ARM64, so fall back to strong static_assert(_Deprecate_non_lock_free_volatile&lt;_Ty&gt;, &quot;Never fails&quot;); return this-&gt;compare_exchange_strong(_Expected, _Desired);&#125; atomic_flag的实现atomic_flag 不一定是bool，比方这里就是long类型，atomic_flag一般是符合标准的最小的硬件实现类型，所以一定是无锁的 12345678910111213struct atomic_flag &#123; bool test_and_set(const memory_order _Order = memory_order_seq_cst) noexcept &#123; return _Storage.exchange(true, _Order) != 0; &#125; void clear(const memory_order _Order = memory_order_seq_cst) noexcept &#123; _Storage.store(false, _Order); &#125;#if 1 // TRANSITION, ABI atomic&lt;long&gt; _Storage;#else // ^^^ don&#x27;t break ABI / break ABI vvv atomic&lt;bool&gt; _Storage;#endif // TRANSITION, ABI&#125;; 内存顺序程序实际的执行过程可能与我们写的顺序是不一致的，这个不一致来自2个方面： 编译器可以依情况在不影响程序运行结果的前提下，为提高运行效率，调整执行顺序 弱顺序内存模型的多核处理器不一定按照顺序执行要保证CPU顺序执行，就需要加入内存栅栏，就像大坝一样，需要上面的代码执行完，才能执行后面的代码先看结论吧结论英文说明是来自：https://en.cppreference.com/w/cpp/atomic/memory_order 内存顺序 说明 std::memory_order_relaxed 同一个线程中, 不同原子变量可以是乱序的 std::memory_order_consume no reads or writes in the current thread dependent on the value currently loaded can be reordered before this load. Writes to data-dependent variables in other threads that release the same atomic variable are visible in the current thread. On most platforms, this affects compiler optimizations only std::memory_order_acquire no reads or writes in the current thread can be reordered before this load. All writes in other threads that release the same atomic variable are visible in the current thread std::memory_order_release no reads or writes in the current thread can be reordered after this store. All writes in the current thread are visible in other threads that acquire the same atomic variable std::memory_order_acq_rel 略 std::memory_order_seq_cst 顺序一致性，所有的线程观察到的整个程序中内存修改顺序是一致的 这部分源码我看了，但根本就没有实现。除了relaxed，其他的内存顺序就是加了个内存栅栏 原子操作的使用场景什么时候用原子操作？让我们先看看原子类型和原子操作能做什么吧 乐观锁/自旋锁 乐观锁和悲观锁是2种思想，一般用CAS来实现乐观锁。乐观锁认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。 利用atomic_flag实现自旋锁，但自旋锁只有在持有锁的时间比较短的情况下(也可以认为锁的粒度比较细的情况下)才比互斥锁有优势，其实上面讲锁的实现时有适应锁的选项，可以当作自旋锁来用。无锁编程无锁编程的优势主要是2个： 避免了死锁、饥饿、饿死的产生，而且能让代码看起来更加简洁。 临界区非常短、竞争激烈的场景，常见的就是无锁的数据结构，而且在内存数据库领域用的很多了。 业界应用：https://www.zhihu.com/question/526298931234567891011121314151617template&lt;class T&gt;struct node&#123; T data; node* next; node(const T&amp; data) : data(data), next(nullptr) &#123;&#125;&#125;;template&lt;class T&gt;struct stack&#123; std::atomic&lt;node&lt;T&gt;*&gt; head; void push(const T&amp; data) &#123; node&lt;T&gt;* new_node = new node&lt;T&gt;(data); new_node-&gt;next = head.load(std::memory_order_relaxed); while (!head.compare_exchange_strong(new_node-&gt;next, new_node, std::memory_order_release)); &#125;&#125;; 无锁编程的ABA问题另一个线程可能会把变量的值从A改成B，又从B改回成A。这就是ABA问题。很多情况下，ABA问题不会影响你的业务逻辑因此可以忽略。但有时不能忽略，这时要解决这个问题，一般的做法是给变量关联一个只能递增、不能递减的版本号。在compare时不但compare变量值，还要再compare一下版本号。","categories":[{"name":"C++基础","slug":"C-基础","permalink":"https://liji53.github.io/categories/C-%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"利用lex和yacc做代码检查(上)","slug":"lexAndYacc","date":"2022-01-13T09:15:34.000Z","updated":"2022-01-13T09:15:34.000Z","comments":true,"path":"2022/01/13/lexAndYacc/","link":"","permalink":"https://liji53.github.io/2022/01/13/lexAndYacc/","excerpt":"","text":"利用lex和yacc做代码检查(上)这篇文章我们将使用lex和yacc来对公司代码进行扫描检查。背景：公司的业务代码是用伪代码和c++来实现的，再由开发工具翻译成c++语言，本次我们要代码检查的就是这些伪代码以及c++代码组成的业务代码，然后找出其中的类型不一致等问题。 预备知识以下的预备知识，对于理解lex和yacc的程序是必须的，因此如果不清楚，须先自学 编译原理, 要求理c/c++解编译器的整体流程、理解词法分析、语法分析概述(转): https://blog.csdn.net/cprimesplus/article/details/105724168 正则表达式，主要在lex语法中用到，要求至少能看懂入门：https://liji53.github.io/2021/12/03/regxStudy/ lex和yacc的语法，2者语法结构类似，yacc比lex要复杂一些，先理解清楚lex，再去理解yacc会容易很多lex入门(转)：https://www.cnblogs.com/wp5719/p/5528896.htmllex和yacc小结(转)：https://www.daimajiaoliu.com/daima/4717f8908900400 c语言的语法文件，要求能看懂。 这两个文件是本次语法分析的基础文件，后续代码都在此基础上添加的c语言lex的语法文件：http://www.quut.com/c/ANSI-C-grammar-l-1998.htmlc语言yacc的语法文件：http://www.quut.com/c/ANSI-C-grammar-y-1998.html 本次词法、语法分析的目标公司的业务代码长这个样子，这种[xxx]的写法就是伪代码，其本质是宏。c++部分的语法分析由于我只找到c的语法分析，而且用c的语法分析对接下来的语法解析足够了，因此直接使用最新的The ANSI C grammar(上文已经提到)，这个文件后续作为待测试文件记test.cpp 12345678910111213// 1）函数调用基本写法：[函数名][入参][出参][function_name][parameter1=1, parameter2=&quot;test&quot;][output1=@id]// 2）函数调用多行写法[function_name2][ parameter1=1, parameter2=&quot;test&quot;][]// 3）宏调用写法,&lt;A-Z&gt; 可无&lt;A&gt;[marco][marco][variable][]// c++语法for(int i = 0; i &lt; 10; i++)&#123; variable1 = variable2;&#125; 先熟悉流程这一步我们通过生成c语言的语法分析器，来熟悉lex和yacc的流程。下载http://www.quut.com/c/ANSI-C-grammar-l-1998.html, 命名c.l下载http://www.quut.com/c/ANSI-C-grammar-y-1998.html, 命名c.y 1. 编译词法文件, 会生成lex.yy.c12# 编译词法文件lex c.l 2. 编译语法文件, 会生成y.tab.c, y.tab.h1234567891011121314151617# 直接编译会出现yacc: 1 shift/reduce conflict. 错误，先编辑c.y文件# 2.1 在c.y的序幕部分加以下内容%nonassoc LOWER_THAN_ELSE%nonassoc ELSE# 2.2 在c.y的规则部分selection_statement修改成以下内容selection_statement : IF &#x27;(&#x27; expression &#x27;)&#x27; statement %prec LOWER_THAN_ELSE | IF &#x27;(&#x27; expression &#x27;)&#x27; statement ELSE statement | SWITCH &#x27;(&#x27; expression &#x27;)&#x27; statement ;# 2.3 在c.y的最后，增加main函数int main(void) &#123; yyparse(); return 0;&#125;# 2.4 编译语法文件，其中-d用来生成头文件yacc -d c.y 3. 生成语法分析器, 生成a.out1gcc y.tab.c lex.yy.c 4. 测试词法分析器12345678# 4.1 写一个简单的c文件,带上错误echo &quot;int main()&#123;a=b&#125;&quot; &gt; test.cpp # 4.2 测试下分析器能不能检查出错误./a.out &lt; test.cpp# 4.3 程序输出结果如下，perfectint main()&#123;a=b&#125; ^ syntax error 词法分析lex在这里词法分析主要对上面示例中的1,2,3种写法进行解析，这里需要判断是否是伪代码，并返回伪代码的标记。由于c.l源文件内容较多，这里只贴修改部分代码 1. 在定义部分，增加2个伪代码的状态标志123456789%&#123;#include &lt;stdio.h&gt; #include &quot;y.tab.h&quot;void count(void);int marco_flag = 0; //伪代码状态，与MARCO_HEAD类似,表示除第一个[xxx]以外的状态%&#125;/* 状态（或条件）定义- 用来标志伪代码头,即第一个[xxx]部分的状态 */%s MARCO_HEAD%% 2. 在规则部分，增加伪代码的规则解析MARCO_SYMBOL_BEGIN、MARCO_NAME等需要在c.y中定义。 12345678910111213141516171819202122&quot;&lt;&quot;[A-Z]&quot;&gt;[&quot; &#123;count(); BEGIN MARCO_HEAD; return(MARCO_SYMBOL_BEGIN); &#125;[ \\t]*&quot;[&quot; &#123;count(); BEGIN MARCO_HEAD; return(MARCO_SYMBOL_BEGIN); &#125;&lt;MARCO_HEAD&gt;&#123;L&#125;(&#123;L&#125;|&#123;D&#125;)* &#123;count(); return(MARCO_NAME); &#125;&lt;MARCO_HEAD&gt;&quot;][&quot; &#123;count(); BEGIN INITIAL; marco_flag = 1; return(MARCO_SYMBOL_SPLIT); &#125; &lt;MARCO_HEAD&gt;&quot;]&quot; &#123;/*必须 写在&lt;MARCO_HEAD&gt;&quot;][&quot; 之后*/ count(); BEGIN INITIAL; return(MARCO_SYMBOL_END); &#125; &lt;MARCO_HEAD&gt;[ \\t\\v\\n\\f] &#123;count(); &#125;&lt;MARCO_HEAD&gt;. &#123;/* ECHO是一个宏，相当于 fprintf(yyout, &quot;%s&quot;, yytext)*/ ECHO; &#125; &quot;]&quot; &#123; count(); if(marco_flag)&#123; if(input() == &#x27;[&#x27;)&#123; return (MARCO_SYMBOL_SPLIT); &#125; else&#123; marco_flag = 0; return (MARCO_SYMBOL_END); &#125; &#125; else&#123; return(&#x27;]&#x27;); &#125; &#125; 这部分代码至少要放在下面代码之前，否则会因为规则的先后匹配错误 12(&quot;[&quot;|&quot;&lt;:&quot;) &#123; count(); return(&#x27;[&#x27;); &#125;(&quot;]&quot;|&quot;:&gt;&quot;) &#123; count(); return(&#x27;]&#x27;); &#125; 测试lex正确性最后我们测试下词法分析器的正确性，待测试文件即上文提到的test.cpp 1. 在c.y中定义部分添加宏定义后面只用到了c.y生成的头文件 1%token MARCO_SYMBOL_BEGIN MARCO_SYMBOL_SPLIT MARCO_SYMBOL_END MARCO_NAME 2. 在c.l中添加main函数123456789101112131415161718192021222324252627void writeout(int c)&#123; switch(c)&#123; case MARCO_SYMBOL_BEGIN: fprintf(yyout, &quot;(MARCO_SYMBOL_BEGIN, \\&quot;%s\\&quot;) &quot;, yytext);break; case MARCO_SYMBOL_SPLIT: fprintf(yyout, &quot;(MARCO_SYMBOL_SPLIT, \\&quot;%s\\&quot;) &quot;, yytext);break; case MARCO_SYMBOL_END: fprintf(yyout, &quot;(MARCO_SYMBOL_END, \\&quot;%s\\&quot;) &quot;, yytext);break; case MARCO_NAME: fprintf(yyout, &quot;(MARCO_NAME, \\&quot;%s\\&quot;) &quot;, yytext);break; case IDENTIFIER: fprintf(yyout, &quot;(IDENTIFIER, \\&quot;%s\\&quot;) &quot;, yytext);break; case CONSTANT: fprintf(yyout, &quot;(CONSTANT, \\&quot;%s\\&quot;) &quot;, yytext);break; case STRING_LITERAL: fprintf(yyout, &quot;(STRING_LITERAL, \\&quot;%s\\&quot;) &quot;, yytext);break; case SIZEOF: fprintf(yyout, &quot;(SIZEOF, \\&quot;%s\\&quot;) &quot;, yytext);break; default:break; &#125;&#125;int main (int argc, char ** argv)&#123; int c; if (argc&gt;=2)&#123; if ((yyin = fopen(argv[1], &quot;r&quot;)) == NULL)&#123; printf(&quot;Can&#x27;t open file %s\\n&quot;, argv[1]); return -1; &#125; while (c = yylex())&#123; writeout(c); &#125; fclose(yyin); &#125; return 0;&#125; 3. 编译词法分析器1lex lex.l &amp;&amp; yacc -d yacc.y &amp;&amp; gcc lex.yy.c 4. 测试test.cpp12345678910111213[liji@null test_compile]$ ./a.out test.cpp[(MARCO_SYMBOL_BEGIN, &quot;[&quot;) function_name(MARCO_NAME, &quot;function_name&quot;) ][(MARCO_SYMBOL_SPLIT, &quot;][&quot;) parameter1(IDENTIFIER, &quot;parameter1&quot;) =1(CONSTANT, &quot;1&quot;) , parameter2(IDENTIFIER, &quot;parameter2&quot;) =&quot;test&quot;(STRING_LITERAL, &quot;&quot;test&quot;&quot;) ](MARCO_SYMBOL_SPLIT, &quot;]&quot;) output1(IDENTIFIER, &quot;output1&quot;) =id(IDENTIFIER, &quot;id&quot;) ](MARCO_SYMBOL_END, &quot;]&quot;) [(MARCO_SYMBOL_BEGIN, &quot;[&quot;) function_name2(MARCO_NAME, &quot;function_name2&quot;) ][(MARCO_SYMBOL_SPLIT, &quot;][&quot;) parameter1(IDENTIFIER, &quot;parameter1&quot;) =1(CONSTANT, &quot;1&quot;) , parameter2(IDENTIFIER, &quot;parameter2&quot;) =&quot;test&quot;(STRING_LITERAL, &quot;&quot;test&quot;&quot;) ](MARCO_SYMBOL_SPLIT, &quot;]&quot;) ](MARCO_SYMBOL_END, &quot;]&quot;) &lt;A&gt;[(MARCO_SYMBOL_BEGIN, &quot;&lt;A&gt;[&quot;) marco(MARCO_NAME, &quot;marco&quot;) ](MARCO_SYMBOL_END, &quot;]&quot;) [(MARCO_SYMBOL_BEGIN, &quot;[&quot;) marco(MARCO_NAME, &quot;marco&quot;) ][(MARCO_SYMBOL_SPLIT, &quot;][&quot;) xxx(IDENTIFIER, &quot;xxx&quot;) ](MARCO_SYMBOL_SPLIT, &quot;]&quot;) ](MARCO_SYMBOL_END, &quot;]&quot;) for(int i(IDENTIFIER, &quot;i&quot;) = 0(CONSTANT, &quot;0&quot;) ; i(IDENTIFIER, &quot;i&quot;) &lt; 10(CONSTANT, &quot;10&quot;) ; i(IDENTIFIER, &quot;i&quot;) ++)&#123; variable1(IDENTIFIER, &quot;variable1&quot;) = variable2(IDENTIFIER, &quot;variable2&quot;) ; 从上文的第7行， ](MARCO_SYMBOL_SPLIT, “]”)这个内容其实是有问题的。 因为在规则部分，处理”]”的时候，用到了input()来判断下个字符是不是”[“， 因此yytext的值是”]”，其实应该是”][“","categories":[],"tags":[]},{"title":"smart_ptr","slug":"smart-ptr","date":"2022-01-08T21:48:07.000Z","updated":"2022-01-08T21:48:07.000Z","comments":true,"path":"2022/01/08/smart-ptr/","link":"","permalink":"https://liji53.github.io/2022/01/08/smart-ptr/","excerpt":"","text":"智能指针的实现shared_ptr 的实现我们都知道靠引用计数，但引用计数的生命周期是怎么样的，智能指针是否线程安全，weak_ptr是否需要计数？现在我们通过阅读源码，来一探究竟。 shared_ptr的实现代码来自vs的memory.h,用的是c++14标准 构造函数(c++11动态数组，需要显式提供delete functor)在vs中神奇的发现c++17才支持的动态数组，c++14就支持了 12345678910111213141516171819202122template &lt;class _Ty&gt;class shared_ptr : public _Ptr_base&lt;_Ty&gt; &#123; explicit shared_ptr(_Ux* _Px) &#123; // construct shared_ptr object that owns _Px /// 已经能自动选择数组类型的删除器 if constexpr (is_array_v&lt;_Ty&gt;) &#123; _Setpd(_Px, default_delete&lt;_Ux[]&gt;&#123;&#125;); &#125; else &#123; _Temporary_owner&lt;_Ux&gt; _Owner(_Px); /// 由于shared_ptr的生命周期随时可以结束，因此引用计数器必须是在heap上 _Set_ptr_rep_and_enable_shared(_Owner._Ptr, new _Ref_count&lt;_Ux&gt;(_Owner._Ptr)); _Owner._Ptr = nullptr; &#125; &#125; _NODISCARD _Elem&amp; operator[](ptrdiff_t _Idx) const noexcept /* strengthened */ &#123; return get()[_Idx]; &#125;&#125;；// 测试std::cout &lt;&lt; __cplusplus &lt;&lt; std::endl; // 201402std::shared_ptr&lt;int[]&gt; p_list(new int[4]&#123; 1,2,3,4 &#125;); // 本来应该在c++17中才支持的std::cout &lt;&lt; p_list[1] &lt;&lt; std::endl; // 2，同上 拷贝构造/移动构造函数/赋值移动系列的函数，会使原shared_ptr变成空指针赋值会使原shared_ptr引用计数减一 12345678910111213141516171819202122shared_ptr(const shared_ptr&amp; _Other) noexcept &#123; // construct shared_ptr object that owns same resource as _Other this-&gt;_Copy_construct_from(_Other);&#125;void _Copy_construct_from(const shared_ptr&lt;_Ty2&gt;&amp; _Other) noexcept &#123; // implement shared_ptr&#x27;s (converting) copy ctor _Other._Incref(); _Ptr = _Other._Ptr; _Rep = _Other._Rep;&#125;void _Move_construct_from(_Ptr_base&lt;_Ty2&gt;&amp;&amp; _Right) noexcept &#123; // implement shared_ptr&#x27;s (converting) move ctor and weak_ptr&#x27;s move ctor _Ptr = _Right._Ptr; _Rep = _Right._Rep; _Right._Ptr = nullptr; _Right._Rep = nullptr;&#125;/// 减一是因为shared_ptr(_Right)是个临时变量，在swap出作用域之后就析构shared_ptr&amp; operator=(const shared_ptr&lt;_Ty2&gt;&amp; _Right) noexcept &#123; shared_ptr(_Right).swap(*this); return *this;&#125; weak_ptr的实现weak_ptr 类型指针不会导致堆内存空间的引用计数增加或减少。另外weak_ptr没有实现operator-&gt;和operator* 构造函数12345678910111213141516171819template &lt;class _Ty&gt;class weak_ptr : public _Ptr_base&lt;_Ty&gt; &#123; weak_ptr(const weak_ptr&amp; _Other) noexcept &#123; this-&gt;_Weakly_construct_from(_Other); // same type, no conversion &#125; weak_ptr(const shared_ptr&lt;_Ty2&gt;&amp; _Other) noexcept &#123; this-&gt;_Weakly_construct_from(_Other); // shared_ptr keeps resource alive during conversion &#125; /// 不增加shared_ptr的引用计数，增加weak_ptr的引用计数 void _Weakly_construct_from(const _Ptr_base&lt;_Ty2&gt;&amp; _Other) noexcept &#123; // implement weak_ptr&#x27;s ctors if (_Other._Rep) &#123; _Ptr = _Other._Ptr; _Rep = _Other._Rep; _Rep-&gt;_Incwref(); &#125; else &#123; _STL_INTERNAL_CHECK(!_Ptr &amp;&amp; !_Rep); &#125; &#125;&#125; lock函数123456789101112131415_NODISCARD shared_ptr&lt;_Ty&gt; lock() const noexcept &#123; // convert to shared_ptr shared_ptr&lt;_Ty&gt; _Ret; (void) _Ret._Construct_from_weak(*this); return _Ret;&#125;bool _Construct_from_weak(const weak_ptr&lt;_Ty2&gt;&amp; _Other) noexcept &#123; // implement shared_ptr&#x27;s ctor from weak_ptr, and weak_ptr::lock() if (_Other._Rep &amp;&amp; _Other._Rep-&gt;_Incref_nz()) &#123; _Ptr = _Other._Ptr; _Rep = _Other._Rep; return true; &#125; return false;&#125; 引用计数通过前面的源码大家也可以看出来，shared_ptr和weak_ptr在交换指针时并不是线程安全的，但引用计数却是线程安全的shared_ptr的引用计数为0，管理的对象可以销毁，但引用计数对象可能仍然存在，需要weak_ptr的引用计数也为0，才销毁 接口与成员变量12345678910111213141516171819202122232425262728#define _MT_INCR(x) _INTRIN_RELAXED(_InterlockedIncrement)(reinterpret_cast&lt;volatile long*&gt;(&amp;x))#define _MT_DECR(x) _INTRIN_ACQ_REL(_InterlockedDecrement)(reinterpret_cast&lt;volatile long*&gt;(&amp;x))class __declspec(novtable) _Ref_count_base &#123; virtual void _Destroy() noexcept = 0; // destroy managed resource virtual void _Delete_this() noexcept = 0; // destroy self _Atomic_counter_t _Uses = 1; _Atomic_counter_t _Weaks = 1;/// 原子操作 void _Incref() noexcept &#123; // increment use count _MT_INCR(_Uses); &#125; void _Incwref() noexcept &#123; // increment weak reference count _MT_INCR(_Weaks); &#125;/// shared_ptr的引用计数为0，则释放资源对象 void _Decref() noexcept &#123; // decrement use count if (_MT_DECR(_Uses) == 0) &#123; _Destroy(); _Decwref(); &#125; &#125;/// 只有weak_ptr的引用计数为0，才释放引用计数 void _Decwref() noexcept &#123; // decrement weak reference count if (_MT_DECR(_Weaks) == 0) &#123; _Delete_this(); &#125; &#125;&#125;;","categories":[{"name":"C++基础","slug":"C-基础","permalink":"https://liji53.github.io/categories/C-%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"正则表达式入门","slug":"regxStudy","date":"2021-12-03T02:22:13.000Z","updated":"2021-12-03T02:22:13.000Z","comments":true,"path":"2021/12/03/regxStudy/","link":"","permalink":"https://liji53.github.io/2021/12/03/regxStudy/","excerpt":"","text":"正则表达式从入门到工作最近工作中用到了很多正则表达式，多少需要记录下使用心得。但一直犹豫要不要写这篇文章，因为网上的正则表达式太多，但想到，写笔记是为了以后的方便，还是决定做吧，而且除了要写基础的，更要写一些特色出来。 是什么简单来说，正则表达式就是用来对文件(字符串)进行匹配的语言(规则)，匹配到之后呢，就可以对文本进行增删改查，增删改查跟语言相关，因此不涉及这方面知识，当然示例代码用的是python 正则表达式的广泛应用最开始接触正则是在shell命令下的grep、sed、awk，后来用的python、js等语言也都支持(包括C++在C11标准中也支持了正则).擅长用工具的人，还能发现像notepad、Everything等各种工具都支持正则,正则表达式就像基础功能一样，不管在编程语言中，还是工具中都有广泛的应用 学习资料，网站正是如此的广泛的应用，因此网上学习资料是不缺的。 在线测试用具：https://tool.oschina.net/regex 常用正则表达式(转)：https://blog.csdn.net/sirobot/article/details/89478951 正则表达式原理(转)：https://zhuanlan.zhihu.com/p/107836267 正则表达式入门基础语法1. 匹配普通文本12re.search(r&#x27;hello world&#x27;,&#x27;example hello world!&#x27;)# &lt;re.Match object; span=(8, 19), match=&#x27;hello world&#x27;&gt; 匹配任意一个字符.(除了换行符\\n) 12re.search(r&#x27;..llo&#x27;,&#x27;example hello world!&#x27;)#&lt;re.Match object; span=(8, 13), match=&#x27;hello&#x27;&gt; 2. 匹配字符组[]虽然叫字符组，但其实匹配的还是一个字符，只不过这个字符是一个范围 123# 匹配axample，bxample，cxample,[abc]表示a或b或cre.search(r&#x27;[abc]xample&#x27;,&#x27;cxample hello world!&#x27;)# &lt;re.Match object; span=(0, 7), match=&#x27;cxample&#x27;&gt; 如果字符很多，可以使用-来表示一个范围的字符 123# 匹配axample，bxample，cxample,[a-c]等价[abc]re.search(r&#x27;[a-c]xample&#x27;,&#x27;cxample hello world!&#x27;)# &lt;re.Match object; span=(0, 7), match=&#x27;cxample&#x27;&gt; 还可以用^来表示非的意思 123# 匹配axample，bxample，cxample,[^d-z]等价[abc]re.search(r&#x27;[^d-z]xample&#x27;,&#x27;cxample hello world!&#x27;)# &lt;re.Match object; span=(0, 7), match=&#x27;cxample&#x27;&gt; 3. 转义字符 \\转义字符主要是为了匹配一些无法表达的特殊字符，如\\t,\\n等。转义字符跟字符集一样，仅匹配一个字符 123# 这里\\t匹配制表符re.search(r&#x27;\\texample&#x27;,&#x27; example hello world!&#x27;)#&lt;re.Match object; span=(0, 8), match=&#x27;\\texample&#x27;&gt; 转义字符也可以用来表示一类字符，如\\w,\\d,\\s等 123# 这里\\w 等价[a-z0-9_]re.search(r&#x27;\\w&#x27;,&#x27; example hello world!&#x27;)# &lt;re.Match object; span=(1, 2), match=&#x27;e&#x27;&gt; 数量词前面的基础语法都只能匹配一个字符，如果需要匹配多次，下面的数量词就派上用场了,数量词需要在字符之后 1. 基础数量词匹配0次或者无限次*匹配1次或者无限次+匹配0次或者1次？ 123456# 匹配至少一个空白字符 后接 至少一个[a-z0-9_]字符 re.search(r&#x27;\\s+\\w+&#x27;,&#x27;example hello_world!&#x27;)# &lt;re.Match object; span=(7, 19), match=&#x27; hello_world&#x27;&gt;# 匹配0个或一个空白字符 后接 至少一个[a-z0-9_]字符re.search(r&#x27;\\s?\\w+&#x27;,&#x27;example hello_world!&#x27;)# &lt;re.Match object; span=(0, 7), match=&#x27;example&#x27;&gt; 2. 匹配诺干次{m} 匹配前一个字符m次{n,m} 匹配前一个字符n至m次 123# 匹配数字 4到5次re.search(r&#x27;\\d&#123;4,5&#125;&#x27;,&#x27;1 22 333 4444&#x27;)# &lt;re.Match object; span=(9, 13), match=&#x27;4444&#x27;&gt; 字符边界(位置匹配)字符边界简单来说就是匹配字符在哪个位置, 但除了^和$常用，平常用的比较少。对于边界字符的理解，可以把位置看成空字符，即”” 1. 简单常用位置符号^表示开头$表示结尾 123# 不匹配&#x27;11 21&#x27;re.search(r&#x27;^\\d+ 22$&#x27;,&#x27;11 22&#x27;)# &lt;re.Match object; span=(0, 5), match=&#x27;11 22&#x27;&gt; 2. 其他位置符号\\b是单词边界，就是\\w和\\W之间的位置\\B是\\b的反面，即非单词边界 123# 从结果可以看到，还包括\\w和^、$之间的位置re.sub(r&#x27;\\b&#x27;,&quot;@&quot;,&#x27;1.Hello world&#x27;)# &#x27;@1@.@Hello@ @world@&#x27; 3. 先行断言(?=exp) 其中exp是一个子表达式，即exp前面的位置。(?!exp) 与上面相反 12345# 把位置理解成&quot;&quot;,这里就是在ll字符前面的空字符替换成@re.sub(r&#x27;(?=ll)&#x27;,&quot;@&quot;,&#x27;1.Hello worlld&#x27;)# &#x27;1.He@llo wor@lld&#x27;re.sub(r&#x27;(?!ll)&#x27;,&quot;@&quot;,&#x27;1.Hello worlld&#x27;)# &#x27;@1@.@H@el@l@o@ @w@o@rl@l@d@&#x27; 分组和引用前面讲了字符组[ab], 但这只能表示一个字符, 如果想要匹配ab或者cd就无能为力了；又或者ab*, *只作用于一个字符，你想要把ab作为一个整体匹配多次，同样无能为力。分组用于解决这些问题，分组也可以认为是子表达式 1. 分组(exp) 其中exp是子表达|式 表示左右任意匹配一个 123# 匹配&#x27;.&#x27;前面是数字或者字母的re.search(r&#x27;(\\d+|[a-zA-Z]+)\\.&#x27;,&#x27;1.hello&#x27;)# &lt;re.Match object; span=(0, 2), match=&#x27;1.&#x27;&gt; 2. 引用引用是为了对重复出现的文本进行匹配，要引用需要先分组(exp) 会自动产生编号，从1开始;&lt;number&gt; 引用编号为number的分组匹配到的字符串(?:exp) 不会捕获，即不会有编号(?P&lt;name&gt;exp) 定义一个命名分组;(?P=name)引用别名为name的分组匹配到的字符串 123456789# 常用于匹配html标签re.search(r&#x27;&lt;([a-z]+)&gt;.*&lt;/\\1&gt;&#x27;,&#x27;&lt;span&gt;xxx&lt;/span&gt;&#x27;)# &lt;re.Match object; span=(0, 16), match=&#x27;&lt;span&gt;xxx&lt;/span&gt;&#x27;&gt;# (?:span) 不捕获，没有编号re.search(r&#x27;&lt;(?:span)&gt;&lt;(div)&gt;.*&lt;/\\1&gt;&#x27;,&#x27;&lt;span&gt;&lt;div&gt;xxx&lt;/div&gt;&#x27;)# &lt;re.Match object; span=(0, 20), match=&#x27;&lt;span&gt;&lt;div&gt;xxx&lt;/div&gt;&#x27;&gt;# 使用别名re.search(r&#x27;&lt;(?P&lt;name1&gt;\\w+)&gt;&lt;(?P&lt;name2&gt;h[1-5])&gt;.*&lt;/(?P=name2)&gt;&lt;/(?P=name1)&gt;&#x27;,&#x27;&lt;html&gt;&lt;h1&gt;xxx&lt;/h1&gt;&lt;/html&gt;&#x27;)# &lt;re.Match object; span=(0, 25), match=&#x27;&lt;html&gt;&lt;h1&gt;xxx&lt;/h1&gt;&lt;/html&gt;&#x27;&gt; 正则表达式不能干的事几乎所有讲正则表达式的博客，都是在说正则表达式无所不能，这里我结合实际，把实际中无法直接用正则匹配的情况说下，当然也可能是我水平不够，写不出来。 1. 不能(^abc)字符集可以[^abc]，表示非abc的字符；但没有表示非abc字符串的表达式，(^abc),^表示的是开头 2. 不能就近匹配比方“select a from select a into b”, 我希望匹配离into最近的select，但事与愿违 总结我写的内容虽然没有覆盖全正则表达式的所有语法，但作为入门足够了。正如前面写的，正则表达式在工具中也有广泛应用，在平常工作中可以多用正则表达式来查找文件，查找奇奇怪怪的内容，对工作效率提升up","categories":[],"tags":[]},{"title":"stl_allocator","slug":"stl-allocator","date":"2021-10-11T19:04:04.000Z","updated":"2021-10-11T19:04:04.000Z","comments":true,"path":"2021/10/11/stl-allocator/","link":"","permalink":"https://liji53.github.io/2021/10/11/stl-allocator/","excerpt":"","text":"分配器杂谈分配器在stl的容器中用于空间的分配与释放，以及对象的初始化与析构，下面我们简单了解下stl 6大组件中的allocator 分配器的任务与接口基本接口上面讲到了分配器的任务，而对应的接口就是 12345678template &lt;class T&gt;T* allocator&lt;T&gt;::allocate(size_type n);template &lt;class T&gt;void allocator&lt;T&gt;::deallocate(T* ptr);template &lt;class T&gt;void allocator&lt;T&gt;::construct(T* ptr);template &lt;class T&gt;void allocator&lt;T&gt;::destroy(T* ptr) allocate和deallocate 在gcc中的实现就是::operator new和delete而construct 用到了placement new，为的就是调用对象的构造函数而destroy 自然是显式调用析构函数 rebind在allocator的实现中都会有一个rebind的结构体，它的作用是获得其他类型的内存分配器allocator&lt;other&gt; 12345template &lt;typename _Tp1&gt;struct rebind&#123; typedef allocator&lt;_Tp1&gt; other;&#125;; 因为在stl容器中，除了要给对象分配内存，往往还需要给存数据的节点分配内存，比如list，list的设计一般有节点，节点中存放数据和下一个节点，而rebind就是给这个节点分配内存的。 《stl源码剖析》alloc的弃用std::alloc的原理参考：《stl源码剖析》原理图：当申请的内存较大时，直接通过new进行内存分配，当申请小块内存时，使用内存池管理。内存池通过16个数组进行管理，每个数组各自管理大小分别为 8， 16， 24，…128 bytes(8 的倍数)的小额区块，这些区块通过链表的方式链接起来 什么时候弃用的弃用原因参考(官网)：https://gcc.gnu.org/onlinedocs/libstdc++/manual/memory.html#allocator.design_issues弃用版本(官网)：https://gcc.gnu.org/onlinedocs/libstdc++/manual/api.html#table.extension_allocators从gcc3.4版本开始默认使用__gnu_cxx::new_allocator，同时这个版本对分配器做了较大的改动，新增了如bitmap_allocator、mt_allocator等的分配器明明使用内存池的版本比直接使用new进行分配要有优势，但为什么GNU要废弃内存池版本呢，通过官网的解释是为了稳定、兼容。（原文：has the advantage of working correctly across a wide variety of hardware and operating systems, including large clusters）同时指出了内存池的缺点：由于内存的创建销毁顺序的不确定，在内存中加载和释放共享对象时可能有问题。（原文：order-of-destruction and order-of-creation for memory pools may be difficult to pin down with certainty, which may create problems when used with plugins or loading and unloading shared objects in memory） Gnu提供的allocator其他版本现有版本new_allocator：默认版本，使用new和delete管理malloc_allocator：使用malloc和delete管理debug_allocator：会申请相比于目标值稍大一些的内存，并用额外的内存存储size信息。在deallocate中用一个assert()来检查被存储的size信息和将要被释放的内存的size是否一致throw_allocator：具有内存跟踪和标记的功能__pool_alloc ：即上面的旧版本内存池分配器__mt_alloc ： 多线程内存池分配器bitmap_allocator：内存池的基础上用bitmap标记内存块的使用和释放 __mt_alloc的原理资料：https://gcc.gnu.org/onlinedocs/libstdc++/manual/mt_allocator.htmlmt_alloc分为多线程版本和单线程版本，遗憾的是多线程版本只给出了接口，并没有实现。但实际上其实是在pool_allocator的基础上，从1维数组变成2维数组，第二维指线程id。 123456789101112131415161718192021222324/// 多线程池版的内存池，数据结构class __pool&lt;true&gt; : public __pool_base&#123; /// 线程id节点，这些节点会组成一个链表，用于从真实线程id映射到内部线程id（1-4096） struct _Thread_record &#123; _Thread_record* _M_next; /// 下一个空闲线程id size_t _M_id; /// 内部使用的线程id，范围是1到4096 &#125;; union _Block_record&#123; _Block_record* _M_next; /// 下一个空闲节点 size_t _M_thread_id; /// 申请该内存的线程id &#125;; struct _Bin_record &#123; _Block_record** _M_first; /// 一维数组，idx为线程id，存free_list的头节点 _Block_address* _M_address; /// 实际内存块的地址 size_t* _M_free; /// 一维数组，idx为线程id，存空闲内存块计数 size_t* _M_used; /// 一维数组，idx为线程id，存使用内存块计数 __gthread_mutex_t* _M_mutex; /// 互斥锁,申请和释放内存小块时用 &#125;; _Bin_record* _M_bin; /// 一维数组，内存池按2的指数对小内存块进行管理，idx为2的指数 size_t _M_bin_size; ///bin的个数 _Thread_record* _M_thread_freelist; /// 线程id的列表&#125;; bitmap_allocator的原理资料：https://gcc.gnu.org/onlinedocs/libstdc++/manual/bitmap_allocator.html网友分析：https://www.jianshu.com/p/425ab2e81b59","categories":[{"name":"C++基础","slug":"C-基础","permalink":"https://liji53.github.io/categories/C-%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"没有登录认证下解决文件冲突方案","slug":"fileConflict","date":"2021-10-08T21:37:29.000Z","updated":"2021-10-08T21:37:29.000Z","comments":true,"path":"2021/10/08/fileConflict/","link":"","permalink":"https://liji53.github.io/2021/10/08/fileConflict/","excerpt":"","text":"web、后台解决文件冲突需求背景背景是之前给团队做了几个提升软件质量、提升工作效率的工具，这些工具需要通过web来修改后台程序的配置，但随着使用的人越来越多，并发的问题也越来越突出，今天我们主要解决在没有登录认证的情况下，多个用户同时操作文件冲突的问题。 寻找解决方法多人同时操作文件，如何保证文件的并发控制，拿到这个问题，我们首先想到了以下几种解决方向： 通知的方式：简单来说就是让其他人知道现在有人正在修改文件，请不要修改文件，并及时刷新页面 冲突的方式：修改文件并提交时，判断文件的修改时间，如果读配置的时间在修改时间之后，则不允许修改 文件锁的方式：类似svn提交代码的操作，在修改文件之前先对文件加锁，修改完成之后再解锁，保证原子性 经过技术评估，方案2最简单，方案1和方案3都需要花点精力。但从用户角度来说，方案3最好，因此最终选择3。再回到技术上，要实现方案3，需要考虑以下几个技术要点： 服务端需要知道是哪个client在修改配置文件； 什么情况下加锁，释放锁(切换文件的读写模式、切换到其他文件、关闭刷新网页)； 异常情况下如何保证锁释放（断网、浏览器奔溃、加了文件锁但不在电脑前了） 方案设计上面的几个技术要点，解决如下： 虽然没有用户体系，但要识别客户端，可以通过cookie的方案来解决，client随机生成id，server根据client id来记录文件的锁定情况 正常情况下，切换文件模式、关闭刷新网页 这些自然靠js自己判断 异常情况下，我们可以参考保活机制来实现自动解锁；页面长时间不操作，则可以通过js判断 时序图如下： 代码实现1.识别客户端由于我们不需要鉴权认证，仅仅只要能区别客户端用户就行，因此cookie可以客户端自己生成，只需要确保唯一性。关键代码如下(作为C++开发，写前端的代码，大家将就下): 12345678910111213141516171819// 查询浏览器本地cookiefunction get_local_cookie()&#123; cook_list = document.cookie.split(&#x27;;&#x27;) for (var i = 0; i &lt; cook_list.length; i++)&#123; var arr = cook_list[i].split(&#x27;=&#x27;) if (arr[0] == &#x27;name&#x27; &amp;&amp; arr[1].substring(0, 9) == &#x27;autotest_&#x27;)&#123; return arr[1] &#125; &#125; return &#x27;&#x27;&#125;// 获取cookie，没有则生成cookie，有则获取当前cookieif (get_cookie() == &#x27;&#x27;)&#123; url = window.location.href + &#x27;cgi-bin/login.cgi&#x27; url += &quot;?name=autotest_&quot; + Math.round(Math.random()*10000) + Date.parse(new Date()) var request = new XMLHttpRequest(); request.open(&quot;GET&quot;, url, true); request.send(null);&#125; 其实没必要通过服务器返回set-cookie，js可以直接生成存储cookie。后端代码login.cgi： 123456789101112131415161718&#x27;&#x27;&#x27;http协议交互格式：get请求：http://192.168.0.1:8088/cgi-bin/login.cgi?name=(autotest_random+timestamp)response header:&#x27;Set-Cookie&#x27;: name=autotest_random+timestamp&#x27;&#x27;&#x27;def create_cookie(): # 获取数据 form = cgi.FieldStorage() site_name = form.getvalue(&#x27;name&#x27;) # Path 需要设置为/ 否则js无法获取 return &#x27;Set-Cookie: name=%s; Path=/&#x27; % site_nameprint (&#x27;Content-Type: text/html&#x27;)print (create_cookie())print (&#x27;HTTPOnly: false&#x27;)print () 2.保活机制+页面活动检测保活是为了在断网、网页异常的异常情况下，后台能够检测到client异常，并自动进行解锁。 这里js直接用setInterval，如果页面非活动状态会有问题 1234567891011121314151617181920// 后台启动定时器，发送保活包，如果长时间未保活，后台自动解锁myWorker = new Worker(&quot;js/keeplive.js&quot;);myWorker.postMessage(_get_url(&#x27;keeplive&#x27;));// 检查页面是否有人操作，长时间无人操作，则进行文件解锁function eventFunc()&#123; myWorker.postMessage(&quot;init&quot;);&#125;var body = document.querySelector(&quot;html&quot;);body.addEventListener(&quot;click&quot;, eventFunc);body.addEventListener(&quot;keydown&quot;, eventFunc);body.addEventListener(&quot;mousemove&quot;, eventFunc);body.addEventListener(&quot;mousewheel&quot;, eventFunc);myWorker.onmessage = function(e) &#123; is_timeout = e.data if (is_timeout)&#123; cgiHttp(&#x27;releaseLock&#x27;) alert(&quot;长时间未操作，页面强制刷新！&quot;) location.reload() &#125;&#125; keeplive.js 主要用来发保活包，以及判断页面长时间未操作，代码如下： 1234567891011121314151617181920212223242526var url = &#x27;&#x27;var init = 0var interval = 30 * 1000 // 保活发送间隔30svar pageTimeout = 20 * 60 * 1000 // 页面超时20分钟var is_timeout = falseonmessage = function(e) &#123; if (e.data == &#x27;init&#x27;)&#123; init = 0 &#125; else&#123; url = e.data &#125;&#125;setInterval(function()&#123; if (url == &#x27;&#x27; || is_timeout == true)&#123; return &#125; var request = new XMLHttpRequest(); request.open(&quot;GET&quot;, url, true); request.send(null); init += 1 if (init &gt;= pageTimeout/interval)&#123; postMessage(true); /// 通知主线程刷新页面 is_timeout = true &#125;&#125;, interval); keeplive.cgi 是后台用来接收保活包的，并把包转发给管道，由喂狗程序去判断是否异常并解锁 1234567891011121314151617181920&#x27;&#x27;&#x27;http协议交互格式：get请求：http://10.20.147.33:8088/cgi-bin/keeplive.cgi?cook=autotest_***response:&#x27;&#x27;&#x27;# todo 管道没有加锁保护，并发存在问题def _feed_dog(cookie_name): pipe_name = commVariable.pipe_name + &#x27;feedDog&#x27; if not os.path.exists(pipe_name): os.mkfifo(pipe_name) pipe_fd = os.open(pipe_name, os.O_WRONLY) os.write(pipe_fd, cookie_name.encode())form = cgi.FieldStorage()cookie = form.getvalue(&#x27;cook&#x27;)_feed_dog(cookie)print (&#x27;Content-Type: text/html&#x27;)print () 喂狗程序代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576g_lock_times = 3*60 # 3分钟lock_manager = &#x27;/tmp/filelock_manager&#x27;pipe_name = &quot;/tmp/pipefeedDog&quot;g_mutex = threading.Lock()g_file_lock_variable = &#123;&#125;# 更新内存中文件锁的时间戳def update_lock_timestamp(cookie): g_mutex.acquire() for system in g_file_lock_variable: for business in g_file_lock_variable[system]: if cookie == g_file_lock_variable[system][business][0]: g_file_lock_variable[system][business][1] = int(time.time()) g_mutex.release()# 从文件中更新到内存中def _update_lock_from_file(data): # 删除文件锁已经不存在的 for system in list(g_file_lock_variable.keys()): if not data.__contains__(system): g_file_lock_variable.pop(system) continue for business in list(g_file_lock_variable[system].keys()): if not data[system].__contains__(business): g_file_lock_variable[system].pop(business) # 更新新增的文件锁 for system in data: for business in data[system]: if not g_file_lock_variable.__contains__(system): g_file_lock_variable[system] = &#123;business: [data[system][business], int(time.time())]&#125; continue if not g_file_lock_variable[system].__contains__(business): g_file_lock_variable[system][business] = [data[system][business], int(time.time())]# 删除超时的文件锁def _delete_timeout_lock(): isChange = False for system in g_file_lock_variable: for business in list(g_file_lock_variable[system].keys()): # 超时，删除该文件锁 if (int(time.time()) - g_file_lock_variable[system][business][1]) &gt;= g_lock_times: g_file_lock_variable[system].pop(business) isChange = True return isChange# 把内存中的文件锁状态跟新到文件中def update_file_lock(): if not os.path.exists(lock_manager): return with open(lock_manager, &#x27;r+&#x27;, encoding=&quot;utf-8&quot;) as fd: try: data = json.load(fd) except: data = &#123;&#125; g_mutex.acquire() _update_lock_from_file(data) isChange = _delete_timeout_lock() if isChange: fd.seek(0) fd.truncate() content = &#123;s: &#123;b: g_file_lock_variable[s][0] for b in g_file_lock_variable[s]&#125; for s in g_file_lock_variable&#125; fd.write(json.dumps(content)) g_mutex.release()def check_timeout(): update_file_lock() threading.Timer(int(g_lock_times/3), check_timeout).start()# 启动检查是否文件锁是否过期的定时器check_timeout()# 从管道中读cookie,更新文件锁的最新情况if not os.path.exists(pipe_name): os.mkfifo(pipe_name)while True: pipe_fd = os.open(pipe_name, os.O_RDONLY) # 阻塞 cook = os.read(pipe_fd, 100) update_lock_timestamp(cook) os.close(pipe_fd) 3.关闭刷新页面，解锁靠js判断页面关闭、刷新时发送请求 12345678910111213141516// 关闭页面时，进行文件解锁window.onbeforeunload = function()&#123; url = window.location.href + &#x27;cgi-bin/releaseLock.cgi&#x27; const formData = new FormData(); formData.append(&quot;system&quot;, g_system) formData.append(&quot;subSystem&quot;, g_sub_system) formData.append(&quot;business&quot;, g_business) formData.append(&quot;fileName&quot;, g_fileName) formData.append(&quot;cook&quot;, g_cookie) window.navigator.sendBeacon(url, formData)&#125;// 刷新页面时，则强制解锁该client的所有文件锁if (performance.navigation.type == 1)&#123; cgiHttp(&#x27;releaseLock&#x27;) console.log(g_business)&#125; 4.切换模式配置的编辑使用了jsonEditor，只需要监听mode的切换即可 1234567891011121314151617181920var jsonOptions = &#123; mode: &#x27;view&#x27;, modes: [&#x27;view&#x27;, &#x27;code&#x27;, &#x27;tree&#x27;], onError: function(err) &#123; alert(err.toString()); &#125;, onModeChange: function(newMode,oldMode)&#123; if ((newMode == &#x27;code&#x27; || newMode == &#x27;tree&#x27;) &amp;&amp; oldMode == &#x27;view&#x27;)&#123; cgiHttp(&#x27;getLock&#x27;) if (g_response.hasOwnProperty(&#x27;success&#x27;) &amp;&amp; g_response[&#x27;success&#x27;] != true)&#123; alert(&#x27;本文件已经被锁定，请稍后再试&#x27;) g_jsonEditor.setMode(&#x27;view&#x27;) &#125; &#125; else if (newMode == &#x27;view&#x27; &amp;&amp; ((oldMode == &#x27;code&#x27; || oldMode == &#x27;tree&#x27;)))&#123; cgiHttp(&#x27;releaseLock&#x27;) console.log(g_response) &#125; &#125;&#125;; 最终效果","categories":[{"name":"python杂项","slug":"python杂项","permalink":"https://liji53.github.io/categories/python%E6%9D%82%E9%A1%B9/"}],"tags":[]},{"title":"探索difflib(初探匹配算法)","slug":"difflibParse","date":"2021-09-10T08:04:57.000Z","updated":"2021-09-10T08:04:57.000Z","comments":true,"path":"2021/09/10/difflibParse/","link":"","permalink":"https://liji53.github.io/2021/09/10/difflibParse/","excerpt":"","text":"让difflib展示更智能继上一篇文章pytest测试报告自定义比较内容，我们修改了pytest-html的源码，用difflib的html比对方式生成了新的测试报告。但用了之后发现，difflib的行比对效果极差，如果存在几处(测了下3个字符以上)不一致的地方就整行变红色，而不是只显示差异字符。如下图： 我想要的效果是beyond compare这种(只把差异字符标红，而并不是整行变红) 网上百度difflib的实现原理，居然完全空白，于是只能自己看源代码分析原因。 首先我们知道difflib有3种差异模式：”Added “ ; “Changed”; “Deleted”。 现在我们要找为什么我们期望的”Changed”会变成”Added”。 difflib源码分析1. 生成html(table)的源码1234567def make_table(self,fromlines,tolines,fromdesc=&#x27;&#x27;,todesc=&#x27;&#x27;,context=False,numlines=5): # 省略...... return table.replace(&#x27;\\0+&#x27;,&#x27;&lt;span class=&quot;diff_add&quot;&gt;&#x27;). \\ replace(&#x27;\\0-&#x27;,&#x27;&lt;span class=&quot;diff_sub&quot;&gt;&#x27;). \\ replace(&#x27;\\0^&#x27;,&#x27;&lt;span class=&quot;diff_chg&quot;&gt;&#x27;). \\ replace(&#x27;\\1&#x27;,&#x27;&lt;/span&gt;&#x27;). \\ replace(&#x27;\\t&#x27;,&#x27;&amp;nbsp;&#x27;) 2. 匹配度导致的整行变红下面就定位到_fancy_replace 这个函数，这个函数作用是把原字符串替换成标注差异的字符串 1234567891011121314151617181920&quot;&quot;&quot; Example:&gt;&gt;&gt; d = Differ()&gt;&gt;&gt; results = d._fancy_replace([&#x27;abcDefghiJkl\\n&#x27;], 0, 1,... [&#x27;abcdefGhijkl\\n&#x27;], 0, 1)&gt;&gt;&gt; print(&#x27;&#x27;.join(results), end=&quot;&quot;)- abcDefghiJkl? ^ ^ ^+ abcdefGhijkl? ^ ^ ^&quot;&quot;&quot;def _fancy_replace(self, a, alo, ahi, b, blo, bhi): best_ratio, cutoff = 0.74, 0.75 cruncher = SequenceMatcher(self.charjunk) # 省略...... if cruncher.real_quick_ratio() &gt; best_ratio and \\ cruncher.quick_ratio() &gt; best_ratio and \\ cruncher.ratio() &gt; best_ratio: best_ratio, best_i, best_j = cruncher.ratio(), i, j # 省略...... 这里的逻辑是匹配度要达到0.74，就能展示字符差异，而不是整行差异 3. 匹配度与预期不符12345# Where T is the total number of elements in both sequences, and# M is the number of matches, this is 2.0*M / T.def ratio(self): matches = sum(triple[-1] for triple in self.get_matching_blocks()) return _calculate_ratio(matches, len(self.a) + len(self.b)) 按照源码的注释，如果只有个别字符不一样，匹配度应该是很高的。在我自己的例子中，只有5个字符不一样，2个比对的字符串分别有250个字符，按照公式，匹配度应该有2*(250-5)/(250*2)=0.98，但实际却只有0.6多 4. 匹配的块少了这个函数会返回所有匹配的内容。Match(a=3, b=2, size=2)，表示左边字符串第3位开始，右边字符串第2位开始相同，相同字符个数为2个 1234567891011121314151617&quot;&quot;&quot;&gt;&gt;&gt; s = SequenceMatcher(None, &quot;abxcd&quot;, &quot;abcd&quot;)&gt;&gt;&gt; list(s.get_matching_blocks())[Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)]&quot;&quot;&quot;def get_matching_blocks(self): # 省略...... while queue: alo, ahi, blo, bhi = queue.pop() i, j, k = x = self.find_longest_match(alo, ahi, blo, bhi) if k: # if k is 0, there was no matching block matching_blocks.append(x) if alo &lt; i and blo &lt; j: queue.append((alo, i, blo, j)) if i+k &lt; ahi and j+k &lt; bhi: queue.append((i+k, ahi, j+k, bhi)) matching_blocks.sort() 期望是所有匹配的子串都能找到返回，但实际却缺少了几个Match 5. 自动垃圾启发式计算惹的祸这个函数看字面意思是找最长的字串，但实际是有条件的。 123456789101112131415161718def find_longest_match(self, alo=0, ahi=None, blo=0, bhi=None): # 省略...... for i in range(alo, ahi): # look at all instances of a[i] in b; note that because # b2j has no junk keys, the loop is skipped if a[i] is junk j2lenget = j2len.get newj2len = &#123;&#125; for j in b2j.get(a[i], nothing): # a[i] matches b[j] if j &lt; blo: continue if j &gt;= bhi: break k = newj2len[j] = j2lenget(j-1, 0) + 1 if k &gt; bestsize: besti, bestj, bestsize = i-k+1, j-k+1, k j2len = newj2len # 省略...... 这个函数里有一个关键变量b2j， 这个变量维护了字符串中频率很低的字符，以及坐标位置。这么做的目的是为了提高运行效率，毕竟如果要比较的字符串很大，每一个字符都比较很影响效率。因此通过比较个别“冷门”字符就能快速匹配。 自动垃圾启发式计算的定义， 引用官方原文： SequenceMatcher支持使用启发式计算来自动将特定序列项视为垃圾。 这种启发式计算会统计每个单独项在序列中出现的次数。 如果某一项（在第一项之后）的重复次数超过序列长度的 1% 并且序列长度至少有 200 项，该项会被标记为“热门”并被视为序列匹配中的垃圾。 这种启发式计算可以通过在创建SequenceMatcher时将 autojunk 参数设为 False 来关闭。 结论原因找到了，只要匹配的字符串长度超过200字符，就可能匹配度变低。比较遗憾的是HtmlDiff类并没有把autojunk参数暴露出来，因此还是要通过修改源码才行, 修改如下： 1234def _fancy_replace(self, a, alo, ahi, b, blo, bhi): best_ratio, cutoff = 0.74, 0.75 #cruncher = SequenceMatcher(self.charjunk) cruncher = SequenceMatcher(self.charjunk, autojunk=False) 注意：这么改，效率会变低 最后上个效果图：","categories":[{"name":"python杂项","slug":"python杂项","permalink":"https://liji53.github.io/categories/python%E6%9D%82%E9%A1%B9/"}],"tags":[]},{"title":"pytest测试报告自定义比较内容","slug":"pytestHtml","date":"2021-09-09T08:48:22.000Z","updated":"2021-09-09T08:48:22.000Z","comments":true,"path":"2021/09/09/pytestHtml/","link":"","permalink":"https://liji53.github.io/2021/09/09/pytestHtml/","excerpt":"","text":"pytest-html自定义比较内容pytest通过assert进行断言，而断言产生的错误内容是python自带的错误解释。但这个错误内容长这样，是不是一脸懵。 我想要的效果是像beyond compare那样： 预备知识&amp;资料遇到问题，先从网上找资料，其中有几篇文章对了解pytest还是很有帮助的 资料： https://www.cnblogs.com/yoyoketang/p/9748718.html https://www.cnblogs.com/linuxchao/p/linuxchao-pytest-html.html https://www.cnblogs.com/yoyoketang/p/14108144.html 但这些文章，并不是我想要的，于是只能自己从pytest-html的源码入手，定制测试报告 定位pytest-html源码pytest-html的源码不多，还是很容易理解的，实现都在pytest_html/plugins.py文件中 1. 分析测试报告的html通过下图，可以看到我们要修改的测试报告的内容位于 2.定位源码通过找生成div(class=’log’)的代码，可以定位到以下代码，这部分的代码就是用来生成div标签的html 12345678910111213141516171819def _populate_html_log_div(self, log, report): if report.longrepr: # longreprtext is only filled out on failure by pytest # otherwise will be None. # Use full_text if longreprtext is None-ish # we added full_text elsewhere in this file. text = report.longreprtext or report.full_text if html_log_content is None: for line in text.splitlines(): separator = line.startswith(&quot;_ &quot; * 10) if separator: log.append(line[:80]) else: exception = line.startswith(&quot;E &quot;) if exception: log.append(html.span(raw(escape(line)), class_=&quot;error&quot;)) else: log.append(raw(escape(line))) log.append(html.br()) 生成目标html直接上代码， 这里用到了difflib，不要忘记import difflib 由于代码是通过Full diff来判断的，因此调用pytest的时候不要忘加-vv参数选项 123456789101112@staticmethoddef _my_diy_html_log_div(text): if text.find(&#x27;Full diff&#x27;) != -1: idx1 = text.find(&#x27;AssertionError: assert&#x27;) + len(&#x27;AssertionError: assert&#x27;) idx2 = text.find(&#x27;E At index&#x27;) compare_str = text[idx1:idx2] left = compare_str[:compare_str.find(&#x27;==&#x27;)].replace(&#x27;\\\\n&#x27;,&#x27;\\n&#x27;) right = compare_str[compare_str.find(&#x27;==&#x27;)+len(&#x27;==&#x27;):].replace(&#x27;\\\\n&#x27;,&#x27;\\n&#x27;) diff = difflib.HtmlDiff() diff_content = diff.make_file(left.splitlines(), right.splitlines()) return diff_content return None 调用者代码如下： 12345678910111213141516171819def _populate_html_log_div(self, log, report): if report.longrepr: text = report.longreprtext or report.full_text # add by liji html_log_content = self._my_diy_html_log_div(text) if html_log_content is None: for line in text.splitlines(): separator = line.startswith(&quot;_ &quot; * 10) if separator: log.append(line[:80]) else: exception = line.startswith(&quot;E &quot;) if exception: log.append(html.span(raw(escape(line)), class_=&quot;error&quot;)) else: log.append(raw(escape(line))) log.append(html.br()) else: log.append(raw(html_log_content)) 代码最后一句：log.append(raw(html_log_content))，必须要加raw，否则报告长这样 这是因为log.append(html)，字符串html会被转义，’&lt;’、’&gt;’、’&amp;’等会被转义 通过看py/_xmlgen.py 的源码，可以看到raw不会escape 123456def __object(self, obj): #self.write(obj) self.write(escape(unicode(obj)))def raw(self, obj): self.write(obj.uniobj) 最后效果展示 格式是difflib的html格式，大致满足要求了！","categories":[{"name":"python杂项","slug":"python杂项","permalink":"https://liji53.github.io/categories/python%E6%9D%82%E9%A1%B9/"}],"tags":[]},{"title":"oracle数据迁移","slug":"oracleMigration","date":"2021-09-02T06:31:01.000Z","updated":"2021-09-02T06:31:01.000Z","comments":true,"path":"2021/09/02/oracleMigration/","link":"","permalink":"https://liji53.github.io/2021/09/02/oracleMigration/","excerpt":"","text":"数据迁移总结(oracle)此类博客太多的坑，都不完整，要不执行着就报错执行不下去了。总的来说，能不用oracle就不要用，学习成本太高。 方法一:客户端exp/imp(不推荐)1. 环境准备，下载工具下载地址： https://www.oracle.com/cn/database/technologies/instant-client/winx64-64-downloads.html 下载以下2个文件： instantclient-basic-windows.x64-12.2.0.1.0.zip instantclient-tools-windows.x64-12.2.0.1.0.zip 注意：exp和imp工具在tools里，版本12.2.0.1.0 上才有， 2. 环境安装，配置TNS文件解压之后，在exp、imp工具的同级目录下新增Network/Admin/tnsnames.ora文件（环境变量看自己的需求） tnsnames.ora文件内容参考： 123456789ora11g_test = (DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.0.1)(PORT = 1521)) ) (CONNECT_DATA = (SERVICE_NAME = helowinXDB) ) ) 3.使用方法使用之前，需要建立好表空间、用户，这里不详细讲 12exp.exe usr/password@ora11g_test file=usr_export.dmp owner=usrimp.exe usr/password@target_oracle file=usr_export.dmp full=y 4. 存在问题说实在的，报的问题实在太多，很多解决不了，下面是随便罗列的几个，因此放弃这个方法. 123EXP-00113: Feature New Composite Partitioning Method is unsupported. EXP-00107: Feature (BINARY XML) of column XML_CONTENT in tableORA-00904: &quot;DUMMYFLAG&quot;: invalid identifier 方法二：expdp和impdp（不推荐）经历方法一的失败，网上看到有数据泵的方式，因此再次尝试 1. 环境&amp;资料使用数据泵需要10g以上的oracle server版本，同时需要在服务端运行，相关的教程建议看 https://hevodata.com/learn/export-data-from-oracle-using-expdp/#i1 https://docs.oracle.com/cd/E11882_01/server.112/e22490/dp_export.htm#SUTIL200 https://oracle-base.com/articles/10g/oracle-data-pump-10g#TableExpImp 2. 使用方法连接本地数据库 1sqlplus &#x2F; as sysdba 创建连接远程数据库(本地的话不需用)(网上很多教程没有提到这一步，如果不创建，生成的dmp文件在远程的oracle服务器上) 1SQL&gt;create public database link orcl11g connect to system identified by oracle using &#x27;(DESCRIPTION =(ADDRESS_LIST =(ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.0.2)(PORT = 1521)))(CONNECT_DATA =(SERVICE_NAME = test)))&#x27;; 创建dmp文件本地存储路径，并赋予权限 12SQL&gt;create directory data_dir as &#x27;/home/oracle/back/data&#x27;;SQL&gt;Grant read,write on directory data_dir to test; shell下，导出数据(有多种导出模式：导整个数据库、按表空间导、按用户导、按表名导、按查询条件导) 12mkdir -p /home/oracle/back/dataexpdp system/system dumpfile=export.dmp directory=data_dir network_link=orcl11g schemas=test 导入数据（注意：需要先建表空间、用户，即使按整个数据库模式） 1impdp test/*** dumpfile=export.dmp directory=data_dir schemas=test 3. 问题用了方法二，问题同样很多，有些报错解决不了。因此这个方法也放弃 123ORA-14460ORA-26059....... 方法三: 写脚本也试过用plsql的导出用户对象、导出表的方式，但也是动不动就出问题，而且无法实现自动化，想要灵活的定制只能自己写脚本同步数据。下面是相关代码， 工具：python 1. 整体代码结构123456789101112131415161718192021222324252627282930import cx_Oracleimport osg_table_space_name_list = [[&#x27;TEST1_DATA&#x27;, &#x27;test1dat.dbf&#x27;, 1024], [&#x27;TEST2_DATA&#x27;, &#x27;test2dat.dbf&#x27;, 1024]] grant_privilege = [&quot;CONNECT&quot;,&quot;RESOURCE&quot;,&quot;DBA&quot;,&quot;UNLIMITED TABLESPACE&quot;, &quot;select any table&quot;,&quot;create any table&quot;, &quot;drop any table&quot;]g_user_name_list = [[&quot;LJ_TEST&quot;, &quot;TEST1_DATA&quot;, grant_privilege], [&quot;LJ_TEST2&quot;, &quot;LJ_TEST2&quot;, grant_privilege]]exist_table_space_str = &quot;select count(*) from dual where exists(&quot; \\ &quot;select * from v$tablespace a where a.name = upper(&#x27;%s&#x27;))&quot;create_table_space_str = &quot;CREATE TABLESPACE %s DATAFILE &quot; \\ &quot;&#x27;/home/oracle/app/oracle/oradata/helowin/%s&#x27; &quot; \\ &quot;SIZE %dM EXTENT MANAGEMENT LOCAL SEGMENT SPACE MANAGEMENT AUTO&quot;exist_user_name_str = &quot;select count(*) from dual where exists(&quot; \\ &quot;select * from all_users a where a.username = upper(&#x27;%s&#x27;))&quot;create_user_name_str = &quot;CREATE USER %s IDENTIFIED BY test &quot; \\ &quot;DEFAULT TABLESPACE %s TEMPORARY TABLESPACE TEMP&quot;query_table_data_str = &quot;select * from %s.%s&quot;insert_table_data_str = &quot;insert into %s.%s (%s) values (%s)&quot;delete_table_data_str = &quot;truncate table %s.%s&quot;if __name__ == &#x27;__main__&#x27;: client = OracleClient() client.create_table_space() client.create_user_name() client.create_table() client.sync_data() 2.连接数据库12345678910111213141516class OracleClient: def __init__(self): os.environ[&#x27;NLS_LANG&#x27;] = &#x27;SIMPLIFIED CHINESE_CHINA.utf8&#x27; # 待同步的数据库 dsn = cx_Oracle.makedsn(&quot;192.168.0.1&quot;, &#x27;1521&#x27;, service_name=&#x27;test&#x27;) self.m_client = cx_Oracle.connect(&#x27;system&#x27;, &#x27;oracle&#x27;, dsn) self.m_cursor = self.m_client.cursor() # 数据源 src_dsn = cx_Oracle.makedsn(&quot;192.168.0.2&quot;, &#x27;1521&#x27;, service_name=&#x27;test&#x27;) self.m_src_client = cx_Oracle.connect(&#x27;system&#x27;, &#x27;oracle&#x27;, src_dsn) self.m_src_cursor = self.m_src_client.cursor() def __del__(self): self.m_cursor.close() self.m_client.close() self.m_src_cursor.close() self.m_src_client.close() 3. 建立表空间12345678910def create_table_space(self): for table_space_name in g_table_space_name_list: self.m_cursor.execute(exist_table_space_str % table_space_name[0]) data = self.m_cursor.fetchall() # todo: if table space created, should drop and recreate. if data[0][0] != 0: continue self.m_cursor.execute(create_table_space_str % (table_space_name[0], table_space_name[1], table_space_name[2])) self.m_client.commit() 4. 建用户123456789101112def create_user_name(self): for user_name in g_user_name_list: self.m_cursor.execute(exist_user_name_str % user_name[0]) data = self.m_cursor.fetchall() # todo: if user created, should drop and recreate. if data[0][0] != 0: continue self.m_cursor.execute(create_user_name_str % (user_name[0], user_name[1])) for privilege in user_name[2]: self.m_cursor.execute(&quot;GRANT %s TO %s&quot; % (privilege, user_name[0])) self.m_client.commit() 5. 建表1234567891011121314151617181920212223242526272829 def _get_table_name_list(self): src_table_name_list = &#123;&#125; dst_table_name_list = &#123;&#125; for user_name in g_user_name_list: self.m_src_cursor.execute(query_table_name_str % user_name[0]) src_data = self.m_src_cursor.fetchall() src_table_name_list[user_name[0]] = [x[0] for x in src_data] self.m_cursor.execute(query_table_name_str % user_name[0]) data = self.m_cursor.fetchall() dst_table_name_list[user_name[0]] = [x[0] for x in data] return src_table_name_list, dst_table_name_list def _create_table(self, user_name, table_name): query_table_name_str = &quot;select TABLE_NAME from all_tables where OWNER = &#x27;%s&#x27;&quot;query_create_table_str=&quot;select dbms_metadata.get_ddl(&#x27;TABLE&#x27;,&#x27;%s&#x27;,&#x27;%s&#x27;) from dual&quot; self.m_src_cursor.execute(query_create_table_str % (table_name, user_name)) create_table_obj = self.m_src_cursor.fetchall() create_table_str = create_table_obj[0][0].read() self.m_cursor.execute(create_table_str) self.m_client.commit() def create_table(self): src_table_name_list, dst_table_name_list = self._get_table_name_list() for user_name in src_table_name_list: for table_name in src_table_name_list[user_name]: # todo, if table created, should recreated if table_name in dst_table_name_list[user_name]: continue self._create_table(user_name, table_name) 6. 同步数据123456789101112131415161718192021222324252627def _sync_data(self, user_name, table_name): self.m_src_cursor.execute(query_table_data_str % (user_name, table_name)) titles = &#x27;,&#x27;.join([i[0] for i in self.m_src_cursor.description]) data_placeholder = &#x27;,&#x27;.join([&#x27;:&#x27;+str(i+1) for i in range(len(self.m_src_cursor.description))]) try: all_table_data = self.m_src_cursor.fetchall() except cx_Oracle.DatabaseError as msg: print(&quot;\\033[1;31;40mError[%s.%s]:%s \\033[0m&quot; % (user_name, table_name, msg)) return # if contains old data,should drop self.m_cursor.execute(delete_table_data_str % (user_name, table_name)) self.m_client.commit() try: self.m_cursor.executemany(insert_table_data_str % ( user_name, table_name, titles, data_placeholder), all_table_data) except cx_Oracle.DatabaseError as msg: print(&quot;\\033[1;31;40mError[%s.%s]:%s \\033[0m&quot; % (user_name, table_name, msg)) return self.m_client.commit()def sync_data(self): src_table_name_list, dst_table_name_list = self._get_table_name_list() for user_name in src_table_name_list: for table_name in src_table_name_list[user_name]: if table_name not in dst_table_name_list[user_name]: self._create_table(user_name, table_name) self._sync_data(user_name, table_name)","categories":[{"name":"python杂项","slug":"python杂项","permalink":"https://liji53.github.io/categories/python%E6%9D%82%E9%A1%B9/"}],"tags":[]},{"title":"数据监控(influxDb+grafana)","slug":"deployMonitor","date":"2021-07-30T03:02:02.000Z","updated":"2021-07-30T03:02:02.000Z","comments":true,"path":"2021/07/30/deployMonitor/","link":"","permalink":"https://liji53.github.io/2021/07/30/deployMonitor/","excerpt":"","text":"数据监控方案背景&amp;预备知识​ 经过一个月多月的程序运行，数据沉淀在mongodb中，接下来就要考虑统计报表了，数据统计能最直接的体现你的工作价值！ ​ 从网上找了一些数据监控的解决方案，得益于docker的简单部署，让我们在验证方案可行性上省去了大量时间。整体方案：1.使用docker部署InfluxDb和Grafana；2.用influxDb远程连接Mongodb，并用脚本生成influxdb数据；3.最后通过Grafana的web展示出来。 ​ 预备知识： 了解InfluxDb，会使用python或其他语言读写influxdb数据库 了解Grafana，会简单使用对应的web即可 了解mongodb，由于数据源在mongodb，因此需要会从mongodb中读数据 环境部署1. 下载安装包下载地址： https://dl.grafana.com/oss/release/grafana-8.0.6-1.x86_64.rpm https://dl.influxdata.com/influxdb/releases/influxdb-1.7.10.x86_64.rpm 2. 生成docker镜像这里我把2个软件合成了一个镜像。 启动脚本文件run-tool.sh: 12service grafana-server startinfluxd -config /etc/influxdb/influxdb.conf dockerfile文件： 123456789101112131415FROM centos:7COPY influxdb-1.7.10.x86_64.rpm /home/COPY grafana-8.0.6-1.x86_64.rpm /home/COPY run-tool.sh /RUN cd /etc/yum.repos.d/ \\ &amp;&amp; curl -O http://mirrors.aliyun.com/repo/Centos-7.repo \\ &amp;&amp; rm CentOS-Base.repo; mv Centos-7.repo CentOS-Base.repo \\ &amp;&amp; yum clean all; yum makecache; yum -y update \\ &amp;&amp; yum install -y /sbin/service; yum install -y fontconfig \\ &amp;&amp; yum install -y urw-fonts \\ &amp;&amp; cd /home/ \\ &amp;&amp; rpm -ivh influxdb-1.7.10.x86_64.rpm \\ &amp;&amp; rpm -ivh grafana-8.0.6-1.x86_64.rpm \\ &amp;&amp; chmod +x /run-tool.shCMD /run-tool.sh 生成镜像命令： 1docker build -t tool:monitor . 3. 启动容器1docker run --name monitor --privileged -it -p 192.168.0.1:8086:8086 -p 192.168.0.1:3000:3000 -v /home/liji/docker/tmp:/mnt tool:monitor 验证是否部署成功，登录grafana的web界面查看，存在以下登录界面说明部署成功： 数据生成数据生成这个环节是粘合剂，把业务生成的数据通过某种规则转成直观的统计数据，是最核心的步骤。本环节我是通过python对mongodb里的数据进行统计，仅贴部分代码： 1. 连接mongodb、连接influxdb123456789import datetimeimport pymongofrom influxdb import InfluxDBClient# 连接mongodburl = &quot;mongodb://&quot; + g_mongo_ip + &#x27;:&#x27; + g_mongo_portmongo_client = pymongo.MongoClient(url)# 连接influxdbinflux_client = InfluxDBClient(g_influx_ip, g_influx_port, database=&#x27;test&#x27;)influx_client.create_database(g_influx_database) # 没有则创建 2. 统计mongodb的数据(DIY)12mongo_db = mongo_client[mongo_db_name]mongo_db[mongo_col_name].find(&#123;&quot;xxx&quot;: &#123;&quot;$exists&quot;: True&#125;&#125;).count() 3. 写入influxdb(DIY)123456789points = [&#123; &quot;measurement&quot;: mongo_db_name, &quot;time&quot;: datetime.datetime.utcnow().isoformat(&quot;T&quot;), &quot;fields&quot;: &#123; &quot;current_problem_count&quot;:100, &quot;resolve_problem_count&quot;:20 &#125; &#125;]influx_client.write_points(points) 4. 验证数据是否写入在安装了influxdb的环境中运行influx，具体命令可以百度 123456789[root@123106ce0db7 /]# influxConnected to http://localhost:8086 version 1.7.10InfluxDB shell version: 1.7.10&gt; show databases name: databasesname----_internaltest 界面展示这个环节是对grafana的界面操作，我也是刚入门，基本操作如下： 1. 配置数据源 选择influxdb以及选择连接地址端口 选择要连接的数据库，不用怕错误，点击“save &amp; test”的时候，会自动帮你测试连接情况 2. 配置展示面板 选择要展示的数据 3. 结果呈现这个效果是我的效果，暂时已经符合我的预期了哈 网上盗的图，参考 总结整个数据监控部署实现差不多花了2天半时间，在这个过程中让我第一次接触influxdb时间序列数据库，也第一次体验了数据监控的方案。作为开发，使用了你以前没用过的技术，确实很爽，但也要及时总结、温故而知新。","categories":[],"tags":[]},{"title":"花最小的学习成本部署web服务","slug":"deployWeb","date":"2021-07-05T11:51:02.000Z","updated":"2021-07-05T11:51:02.000Z","comments":true,"path":"2021/07/05/deployWeb/","link":"","permalink":"https://liji53.github.io/2021/07/05/deployWeb/","excerpt":"","text":"用httpd给程序搭个web界面当你写完程序，需要做推广时，必不可少的需要有个界面。基于这么一个简单背景，花了5天的时间，给自己的程序搞了个web界面，由于之前没有web的实战经验，又不能花大量精力在学习web上，因此有了这篇学习记录 预备知识主要储备知识还是在前端这块： 了解html、css、js，html和js可以在实际过程中边学边用 了解http协议，主要是出问题的时候，可以抓包快速确定是前端还是后端的问题 了解httpd、cgi，主要是要部署web服务器，以及写后端脚本 总体思路1.明确web做什么既然是花最小的学习成本部署web服务，那就需要清楚页面要做什么事，然后针对性的去学习。例如我这次web要做的是读写后台的配置文件。理想的服务端目录结构是这样的： 12345678&#123; &quot;系统1&quot;:&#123; &quot;子系统1&quot;:&#123; &quot;业务1&quot;:&quot;配置文件1&quot;, &quot;业务2&quot;:&quot;配置文件2&quot; &#125; &#125;&#125; web要修改的就是“配置文件1，配置文件2”。基于这个结构，web页面需要3层导航，分别表示 “系统”、‘’子系统“、“业务”，还需要一个能显示配置，同时能修改配置的地方。 2.找一个静态web页面模板找静态的web页面是为了让我们后续动态生成html有参考模板，同时网上的web页面会比自己从零开始写的要好看，不需要自己搞CSS。 3.部署服务器这里采用httpd作为服务器，使用cgi进行交互。httpd部署过程忽略(建议直接用docker) 4.确定交互协议找到合适的模板，部署好服务之后，就要考虑如何与服务器交互了，一般采用http协议，交互的数据格式为json。具体协议设计忽略 5.动态生成html页面这里主要是通过ajax来动态更新页面。 找静态web页面模板我的情况比较简单，只要能体现3层导航的web页面即可，可以从官网的demo中找 地址：https://getbootstrap.com/docs/5.0/getting-started/download/ 其他专业模板(太高端，没玩过)：https://www.w3cschool.cn/msv2es/qmaj1pyd.html 由于我没有经验，找了1个小时才找到合适的模板，模板长这样： 接着去掉内容，只留下html骨架代码。可以看到三个地方留了id属性，用于后续动态生成html 123456789101112131415161718192021&lt;!-- 最上面的导航 --&gt;&lt;div class=&quot;navbar navbar-fixed-top&quot;&gt; &lt;div class=&quot;navbar-inner&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;!-- id后面动态生成的时候用到 --&gt; &lt;div class=&quot;nav-collapse&quot; id=&#x27;header_system&#x27;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;row-fluid&quot;&gt; &lt;!-- 左边的导航栏 --&gt; &lt;div class=&quot;span3&quot;&gt; &lt;div class=&quot;well sidebar-nav&quot; id=&#x27;left_config&#x27;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 右边配置展示 --&gt; &lt;div class=&quot;span7&quot;&gt; &lt;div style=&quot;padding: 10px 10px 10px;&quot; id=&#x27;right_config&#x27;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 部署服务下载httpd的镜像，启动容器，命令如下： 123456docker pull centos/httpddocker run --name=myHttpd -it -p 192.168.0.1:8089:80 \\ -v /home/liji/apache/html:/var/www/html/ \\ -v /home/liji/apache/cgi-bin:/var/www/cgi-bin/ \\ -v /home/liji/apache/conf:/etc/httpd/conf \\ centos/httpd 修改httpd.conf，前面已经做好路径映射，直接修改/home/liji/apache/conf/httpd.conf 123456&lt;Directory &quot;/var/www/cgi-bin&quot;&gt; AllowOverride None SetHandler cgi-script Options ExecCGI Require all granted&lt;/Directory&gt; 重启httpd容器 1docker restart myHttpd cgi脚本可以用shell，也可以用python， 如果用python则还需要在容器内安装python，可以参考上一篇博客 测试CGI在html中随便加个能发请求的button，用于测试 1&lt;button type=&quot;button&quot; onclick=&quot;cgiHttp(&#x27;test&#x27;)&quot;&gt;测试CGI&lt;/button&gt; js发送请求代码如下： 1234567891011function cgiHttp(func)&#123; url = window.location.href + &#x27;cgi-bin/&#x27; + func + &#x27;.cgi&amp;arg=test&#x27; var request = new XMLHttpRequest() request.onreadystatechange = function() &#123; if (request.readyState==4 &amp;&amp; request.status==200)&#123; alert(request.responseText) &#125; &#125; request.open(&quot;GET&quot;, url, true) request.send(null)&#125; web服务端，在/home/liji/apache/cgi-bin目录下新建test.cgi，内容如下： 12345678import cgi, cgitbimport jsonform = cgi.FieldStorage()# 获取数据site_arg = form.getvalue(&#x27;arg&#x27;)print(&quot;Content-type:text/html&quot;)print()print(&quot;cgi test success! arg = %s&quot; % site_arg) 遇到问题的时候首先抓包，如果返回的是500内部服务错误，直接到/etc/httpd/logs/目录下，查看error_log文件 典型的3种错误有： 1.权限问题 1(13)Permission denied: exec of &#x27;/var/www/cgi-bin/test.cgi&#x27; failed 这种可能是test.cgi 没有执行权限，chmod +x test.cgi 解决 如果你写的cgi脚本需要修改其他目录下的文件，则还需要修改相应目录的权限，参考命令 chown -R apache:apache /home/test 2.执行失败 1(2)No such file or directory: exec of &#x27;/var/www/cgi-bin/previousPick.cgi&#x27; failed 检查test.cgi 是否存在windows字符，这个问题我当时花了半小时才找到。vi -b test.cgi，进入文件看有没有 ^M 字符 3.字符编码 1UnicodeEncodeError: &#x27;ascii&#x27; codec can&#x27;t encode characters in position 4-9: ordinal not in range(128) 这个问题比较恶心，在实际的环境中，脚本需要修改其他目录下的配置文件，而这个目录存在中文，就会报错。我用的是python3.6版本，直接运行脚本不会出错，但用apache用户运行就有问题，即使我在httpd.conf中加入环境变量SetEnv PYTHONIOENCODING utf-8依然没有解决，最后只能不用中文的目录来规避 协议交互假设现在设计了4个协议，对应服务端有4个脚本，分别是getSystem.cgi、getBusiness.cgi、getConfig.cgi、setConfig.cgi，js代码如下： 12345678910111213141516171819202122232425262728/// 根据协议的设计，拼装http请求，为了展示效果不冗余，只拼装1个协议function _get_url(func)&#123; url = window.location.href + &#x27;cgi-bin/&#x27; + func + &#x27;.cgi&#x27; if(func == &#x27;getSystem&#x27;)&#123; url += (&quot;?system=&quot; + g_system) &#125;else&#123; alert(&quot;功能尚未实现，敬请期待！&quot;) return null &#125; return url&#125;function cgiHttp(func)&#123; url = _get_url(func) if (url == null)&#123; return &#125; var request = new XMLHttpRequest() request.onreadystatechange = function() &#123; if (request.readyState==4 &amp;&amp; request.status==200)&#123; response_config = JSON.parse(request.responseText) /// 动态加载html页面 load_func = &#x27;_load&#x27; + func + &#x27;Response(response_config)&#x27; eval(load_func) &#125; &#125; request.open(&quot;GET&quot;, url, true) request.send(null)&#125; 动态更新页面根据前面的协议交互，我们已经能收到服务器的响应了，下面就是拼装html。先确定我们的目标长什么样： 1234567891011&lt;div class=&quot;nav-collapse&quot; id=&quot;header_system&quot;&gt; &lt;ul class=&quot;nav&quot;&gt; &lt;li class=&quot;active&quot; id=&quot;system_system1&quot;&gt; &lt;a onclick=&quot;systemClick(&#x27;system1&#x27;)&quot;&gt;system1&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;disabled&quot; id=&quot;system_system2&quot;&gt; &lt;a onclick=&quot;systemClick(&#x27;system2&#x27;)&quot;&gt;system2&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;disabled&quot; id=&quot;system_system3&quot;&gt; &lt;a onclick=&quot;systemClick(&#x27;system3&#x27;)&quot;&gt;system3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;p class=&quot;navbar-text pull-right&quot;&gt;contract liji37951&lt;/p&gt;&lt;/div&gt; 重点是class=”active” 、 id=”system_system1”、systemClick(‘system1’) 这几个字段是动态的。 1234567891011121314151617function _loadgetSystemResponse(systemConfig)&#123; headerInnerHtml = &#x27;&lt;ul class=&quot;nav&quot;&gt;&#x27; for (var i = 0; i &lt; systemConfig.length; i++)&#123; if (i == 0)&#123; headerInnerHtml += &#x27;&lt;li class=&quot;active&quot;&#x27; g_system = systemConfig[i] &#125;else&#123; headerInnerHtml += &#x27;&lt;li class=&quot;disabled&quot;&#x27; &#125; headerInnerHtml += &#x27; id=&quot;system_&#x27; + systemConfig[i] + &#x27;&quot;&gt;&lt;a onclick=&quot;systemClick(\\&#x27;&#x27; + systemConfig[i] + &#x27;\\&#x27;)&quot;&gt;&#x27; + _toChinese(systemConfig[i])+&#x27;&lt;/a&gt;&lt;/li&gt;&#x27; &#125; headerInnerHtml += &#x27;&lt;/ul&gt;&lt;p class=&quot;navbar-text pull-right&quot;&gt;contract liji&lt;/p&gt;&#x27; document.getElementById(&quot;header_system&quot;).innerHTML=headerInnerHtml&#125; 下面就是实现systemClick这个函数。 123456789function systemClick(system)&#123; if (document.getElementById(&quot;system_&quot;+system).className == &#x27;disabled&#x27;)&#123; document.getElementById(&quot;system_&quot;+g_system).className=&#x27;disabled&#x27; g_system = system document.getElementById(&quot;system_&quot;+system).className=&#x27;active&#x27; cgiHttp(&#x27;getBusiness&#x27;, g_system) cgiHttp(&#x27;getConfig&#x27;, g_business) &#125;&#125; 其他左边的导航栏，右边的配置内容， 方法是一致的。 总结这篇文章，无法直接拷贝代码，帮你完成web的搭建。但我写这篇文章，是为了下次遇到类似问题时提供一个思路，这次花5天时间搞定，下次能2天时间搞定，这就是这篇文章的价值。","categories":[],"tags":[]},{"title":"定制docker镜像","slug":"dockerBuild","date":"2021-06-10T02:38:06.000Z","updated":"2021-06-10T02:38:06.000Z","comments":true,"path":"2021/06/10/dockerBuild/","link":"","permalink":"https://liji53.github.io/2021/06/10/dockerBuild/","excerpt":"","text":"定制docker镜像如果你写出来的应用，领导要求要考虑部署简单、可维护，这时候你应该想到docker，以我工作中的环境为例，部署需要用到httpd、mongodb、svn、python3等。但去hub docker上找相应的镜像，往往只能找到基础镜像，因此需要我们定制自己的镜像 。 准备工作1. 下载docker首先需要下载docker，我的环境是centos 7.6 由于是公司服务器环境，使用curl会连接失败，但好在yum能用 123456sudo yum install -y yum-utils device-mapper-persistent-data lvm2# 更新源地址sudo yum-config-manager --add-repo \\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo# 安装Docker Engine-Communitysudo yum install docker-ce docker-ce-cli containerd.io 安装完成之后，启动docker 1sudo systemctl start docker 2. 准备基础镜像我选的基础镜像是centos/httpd 1docker pull centos/httpd 但由于环境问题，会出现连接失败，因此需要手动打包镜像 先从能上网的地方下载镜像，比方先在windows上下载镜像，并打包 1234567C:\\Users\\liji&gt;docker pull centos/httpdC:\\Users\\liji&gt;docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEcentos latest 300e315adb2f 6 months ago 209MBliji1211/hexo V1 f03e20ea2889 11 months ago 289MBspurin/hexo latest f03e20ea2889 11 months ago 289MBcentos/httpd latest 2cc07fbb5000 2 years ago 258MB 12# 打包镜像C:\\Users\\liji&gt;docker save -o centos_httpd.tar 2cc07fbb5000 把本地打包的centos_httpd.tar 上传到服务器，并加载镜像 12# 加载镜像docker load -i centos_httpd.tar 定制镜像定制镜像，有2种方法: 第一种是基于基础镜像，在容器中直接修改下载各种软件，然后再把容器保存成镜像即可。另一种是通过Dockerfile来定制镜像，有点像写makefile，最后通过docker build来创建镜像。下面分别介绍： 使用Dockerfile定制 从网上下载mongodb的安装包，放在与Dockerfile同一级目录下 下载地址：https://www.mongodb.com/try/download/community?jmp=nav 新建Dockerfile，文件内容如下： 123456789101112131415161718FROM centos/httpdENV LANG en_US.UTF-8COPY mongodb-org-* /home/RUN mkdir /root/.pip/COPY pip.conf /root/.pip/RUN cd /etc/yum.repos.d/ \\ &amp;&amp; curl -O http://mirrors.aliyun.com/repo/Centos-7.repo \\ &amp;&amp; rm CentOS-Base.repo; mv Centos-7.repo CentOS-Base.repo \\ &amp;&amp; yum makecache; yum clean all; yum makecache; yum -y update \\ &amp;&amp; yum install -y openssl \\ &amp;&amp; yum install -y openssl-devel \\ &amp;&amp; yum install -y python36 \\ &amp;&amp; pip3 install lxml \\ &amp;&amp; yum install -y subversion \\ &amp;&amp; cd /home/ \\ &amp;&amp; rpm -ivh mongodb-org-server-4.0.24-1.el6.x86_64.rpm \\ &amp;&amp; rpm -ivh mongodb-org-shell-4.0.24-1.el6.x86_64.rpm \\ &amp;&amp; mkdir /home/data; mkdir /home/log; touch /home/log/mongod.log Dockerfile命令解释： FROM：指定基础镜像，会先从本地镜像仓库搜索，如果本地没有，则会网上搜索 ENV：设置系统环境变量 RUN：执行在系统里的命令，注意：有多条命令时，尽量写成一条命令 COPY：把本地文件拷贝到镜像里，这里pip.config内容如下 123[global]trusted-host=mirrors.aliyun.comindex-url=http://mirrors.aliyun.com/pypi/simple/ 构建镜像 1docker build -t test:v1 . 至此，一个安装了httpd、python3.6、mongodb、Svn的镜像就完成 手动修改容器镜像 基于前面的准备工作，我们先启动、进入容器 1docker run -it centos/httpd /bin/bash 进入容器之后，首先更新yum源 1234cd /etc/yum.repos.d/ curl -O http://mirrors.aliyun.com/repo/Centos-7.repo rm CentOS-Base.repo -f; mv Centos-7.repo CentOS-Base.repoyum makecache;yum clean all;yum makecache;yum -y update 下载openssl、python3.6、svn 1234yum install -y opensslyum install -y openssl-devel yum install -y python36yum install -y subversion 更新pip源 123456mkdir /root/.pip/cat &gt; /root/.pip/pip.conf &lt;&lt; EOF[global]trusted-host=mirrors.aliyun.comindex-url=http://mirrors.aliyun.com/pypi/simple/EOF 退出容器，按Ctrl+P，再按Ctrl+Q；然后把mongodb的安装包拷贝到容器中 123# 356e587e2f04是容器iddocker cp mongodb-org-server-4.0.24-1.el6.x86_64.rpm 356e587e2f04:/homedocker cp mongodb-org-shell-4.0.24-1.el6.x86_64.rpm 356e587e2f04:/home 再次进入容器，安装mongodb，并启动mongodb 123456789# 进入容器docker exec -it 356e587e2f04 /bin/bash# 安装mongodbcd /home/ rpm -ivh mongodb-org-server-4.0.24-1.el6.x86_64.rpm rpm -ivh mongodb-org-shell-4.0.24-1.el6.x86_64.rpm mkdir /home/data; mkdir /home/log; touch /home/log/mongod.log# 启动mongodb，但一旦重启容器、新建容器，mongodb需要重新启动mongod --dbpath /home/data/ --logpath /home/log/mongod.log --fork 退出容器，并制作镜像 1docker commit 356e587e2f04 test:v2 至此，镜像制作完成 比较2种方式1234[root@null mongo]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEtest v2 3cd3fd149fd0 45 seconds ago 1.17GBtest v1 150221daf971 4 hours ago 934MB dockerfile的优势： 镜像的体积会更小 可复用","categories":[],"tags":[]},{"title":"史上最详细-用docker部署博客","slug":"deployBlog","date":"2021-04-27T11:00:44.000Z","updated":"2021-04-27T11:00:44.000Z","comments":true,"path":"2021/04/27/deployBlog/","link":"","permalink":"https://liji53.github.io/2021/04/27/deployBlog/","excerpt":"","text":"用docker，hexo，github部署博客hexo+github的部署教程，网上详细教程一堆。如果你觉得安装node.js、npm以及再用npm安装各种模块(安装后还会有大量的安装残余)不爽，那欢迎参考本次教程。我们将使用docker来封装运行hexo，hexo镜像非自己制作，我们网上下载 预备知识通过本次教程，虽然可以完成搭建，但还是建议多储备点知识，这样在遇到环境差异时，能快速排查问题。 了解docker，会用常用命令；参考：https://www.runoob.com/docker/docker-tutorial.html 了解hexo，会用常用命令；参考：https://hexo.io/zh-cn/docs/ 了解git、github、markdown docker安装这里只讲win10安装docker，其他环境，请参考其他博客，网上资料很多，不怕搞不定 启用Hyper，Hyper是win10自带的虚拟化技术，docker会在Hyper虚拟出来的环境上运行 安装docker，下载地址：https://docs.docker.com/docker-for-windows/install/ 一路next即可 安装完成之后，cmd下执行docker version，如下所示，说明安装成功 1234567891011C:\\Users\\hspcadmin&gt;docker versionClient: Docker Engine - Community Cloud integration: 1.0.12 Version: 20.10.5 API version: 1.41 Go version: go1.13.15 Git commit: 55c4c88 Built: Tue Mar 2 20:14:53 2021 OS/Arch: windows/amd64 Context: default Experimental: true 修改镜像仓库的配置，最好自己申请一个阿里云的镜像，速度最快 docker启动hexohexo的镜像，从Docker官方的公共仓库找，网址：https://hub.docker.com/search?q=hexo 我选的是spurin/hexo (100K+下载量，说明用的人挺多的) 下载spurin/hexo镜像(我已经提前下载，所以打印提示已经是最新版本) 123456C:\\Users\\hspcadmin&gt;docker pull spurin/hexoUsing default tag: latestlatest: Pulling from spurin/hexoDigest: sha256:4f8a4d8133d5b29d60b86782237673511b3c3b2081b767064d2b922b53bc2ef5Status: Image is up to date for spurin/hexo:latestdocker.io/spurin/hexo:latest 创建容器，命令如图所示 12C:\\Users\\hspcadmin&gt;docker create --name=liji53.github.com -e HEXO_SERVER_PORT=4001 -e GIT_USER=&quot;liji53&quot; -e GIT_EMAIL=&quot;liji_1211@163.com&quot; -v E:/blog:/app -p 4001:4001 spurin/hexo666891af8d09cdc0443cfe157c3fcf10ab3f9739e72673cdf201a030c66d4c75 详细参数说明： –name 给容器指定名称，方便多个博客的管理(非必须) -e HEXO_SERVER_PORT 指定hexo server的端口(注意这个是容器内部的hexo server端口) -e GIT_USER github账户的账户名称(必须与github上的账号保持一致，还没有的赶紧注册) -e GIT_EMAIL github的注册email -v 路径映射，把hexo的app文件夹映射到本地 -p 将容器内部使用的网络端口随机映射到我们使用的主机上 启动容器，需要一段时间。会自动初始化hexo、下载依赖的插件、创建SSH密钥等。(启动的打印很多，我这里仅展示部分) 123456789101112C:\\Users\\hspcadmin&gt;docker start liji53.github.com &amp;&amp; docker logs --follow liji53.github.comliji53.github.com***** App directory exists and has content, continuing ********** App directory contains a requirements.txt file, installing npm requirements ********** App .ssh directory exists and has content, continuing ********** Running git config, user = liji53, email = liji_1211@163.com ********** Copying .ssh from App directory and setting permissions ********** Contents of public ssh key (for deploy) - ********** Starting server on port 4001 *****INFO Validating configINFO Start processingINFO Hexo is running at http://localhost:4001 . Press Ctrl+C to stop. 检查–本地预览效果，出现以下图片说明部署成功了 ，网址：http://localhost:4001/ 替换hexo主题hexo的主题，我们用的是hueman，地址：https://github.com/ppoffice/hexo-theme-hueman 进入容器（也可以不进入容器，后续步骤可直接在windows的映射路径上操作） 12C:\\Users\\hspcadmin&gt;docker exec -it liji53.github.com bashroot@666891af8d09:/app# 下载主题 123456789root@666891af8d09:/app/themes# git clone https://github.com/ppoffice/hexo-theme-hueman.git themes/huemanCloning into &#x27;themes/hueman&#x27;...remote: Enumerating objects: 2272, done.remote: Counting objects: 100% (11/11), done.remote: Compressing objects: 100% (11/11), done.remote: Total 2272 (delta 1), reused 2 (delta 0), pack-reused 2261Receiving objects: 100% (2272/2272), 5.77 MiB | 37.00 KiB/s, done.Resolving deltas: 100% (1216/1216), done.Checking out files: 100% (241/241), done. 如果出现下面这个问题(fatal: unable to access ‘https://github.com/ppoffice/hexo-theme-hueman.git/&#39;: gnutls_handshake() failed: The TLS connection was non-properly terminated.) 则该改成 1git clone git://github.com/ppoffice/hexo-theme-hueman.git themes/hueman 修改hueman的默认配置名称 1root@666891af8d09:/app# mv themes/hueman/_config.yml.example themes/hueman/_config.yml 修改hexo的全局配置，使用hueman的主题，在windows上修改，本例的文件路径是E:\\blog\\_config.yml（在容器中修改，没有vim，需要下载，下载命令 apt update &amp;&amp; apt -y install vim） 打开_config.yml，找到theme这一行，改成hueman，其他_config.yml的用法参考官网 https://hexo.io/zh-cn/docs/configuration 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hueman 检查–本地预览效果，出现以下图片说明部署成功了，网址：http://localhost:4001/ 如果效果不对，试试重启容器，命令： 1docker restart liji53.github.com &amp;&amp; docker logs --follow liji53.github.com 搭建github博客首先，要注册一个github的账号，注册的邮箱必须要验证，这步就不贴图了 创建仓库 仓库的名字必须是username.github.io，其中username是你的用户名 配置SSH Key当你本地写完博客，提交代码时，必须有github权限才可以，直接使用用户名和密码每次都要输入，很不方便。因此我们使用ssh key来解决这个问题 前面搭建docker+hexo的过程中，已经提到hexo容器帮我们生成了ssh密钥，不需要调用ssh-keygen 密钥的路径在本地映射路径下，参考： 记事本打开.ssh\\id_rsa.pub文件，复制里面的内容，打开你的github主页，进入个人设置-&gt;SSH and GPG keys -&gt; New SSH key, 将刚复制的内容粘贴到key哪里，title随便填 用hexo写博客并上传到这一步，环境已经搭建完成了，只剩考虑该写啥了。。。接下来我们简单验证下 在容器环境下，用命令生成文件；在到windows环境下，打开test.md随便写几句 123root@666891af8d09:/app# hexo new testINFO Validating configINFO Created: /app/source/_posts/test.md 进入容器，用hexo生成博客静态网页(会生成public目录，里面就是生成的网页) 1234567891011root@666891af8d09:/app# hexo gINFO Validating configINFO Start processingDeprecated as of 10.7.0. highlight(lang, code, ...args) has been deprecated.Deprecated as of 10.7.0. Please use highlight(code, options) instead.https://github.com/highlightjs/highlight.js/issues/2277INFO Files loaded in 2.6 sINFO Generated: content.jsonINFO Generated: archives/index.htmlINFO Generated: archives/2021/index.htmlINFO Generated: index.html 上传博客(用hexo d命令只会上传public目录，其他不会上传) 123456789root@666891af8d09:/app# hexo dINFO Validating configINFO Start processingDeprecated as of 10.7.0. highlight(lang, code, ...args) has been deprecated.Deprecated as of 10.7.0. Please use highlight(code, options) instead.https://github.com/highlightjs/highlight.js/issues/2277INFO Files loaded in 2.48 sINFO Generated: content.jsonINFO Generated: archives/index.html 检查–网站预览效果 常见问题及参考 github访问慢、访问失败 参考：https://zhuanlan.zhihu.com/p/15893854 博客图片路径加载失败 参考：https://blog.csdn.net/xjm850552586/article/details/84101345 其他参考 https://spurin.com/2020/01/04/Creating-a-Blog-Website-with-Docker-Hexo-Github-Free-Hosting-and-HTTPS/ https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html","categories":[],"tags":[]}],"categories":[{"name":"C++基础","slug":"C-基础","permalink":"https://liji53.github.io/categories/C-%E5%9F%BA%E7%A1%80/"},{"name":"python杂项","slug":"python杂项","permalink":"https://liji53.github.io/categories/python%E6%9D%82%E9%A1%B9/"}],"tags":[]}