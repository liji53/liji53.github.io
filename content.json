{"meta":{"title":"么么博客","subtitle":"","description":"程序猿个人随记","author":"Liji","url":"https://liji53.github.io","root":"/"},"pages":[],"posts":[{"title":"oracle数据迁移","slug":"oracleMigration","date":"2021-09-02T06:31:01.000Z","updated":"2021-09-02T06:31:01.000Z","comments":true,"path":"2021/09/02/oracleMigration/","link":"","permalink":"https://liji53.github.io/2021/09/02/oracleMigration/","excerpt":"","text":"数据迁移总结(oracle)此类博客太多的坑，都不完整，要不执行着就报错执行不下去了。总的来说，能不用oracle就不要用，学习成本太高。 方法一:客户端exp/imp(不推荐)1. 环境准备，下载工具下载地址： https://www.oracle.com/cn/database/technologies/instant-client/winx64-64-downloads.html 下载以下2个文件： instantclient-basic-windows.x64-12.2.0.1.0.zip instantclient-tools-windows.x64-12.2.0.1.0.zip 注意：exp和imp工具在tools里，版本12.2.0.1.0 上才有， 2. 环境安装，配置TNS文件解压之后，在exp、imp工具的同级目录下新增Network/Admin/tnsnames.ora文件（环境变量看自己的需求） tnsnames.ora文件内容参考： 123456789ora11g_test = (DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.0.1)(PORT = 1521)) ) (CONNECT_DATA = (SERVICE_NAME = helowinXDB) ) ) 3.使用方法使用之前，需要建立好表空间、用户，这里不详细讲 12exp.exe usr/password@ora11g_test file=usr_export.dmp owner=usrimp.exe usr/password@target_oracle file=usr_export.dmp full=y 4. 存在问题说实在的，报的问题实在太多，很多解决不了，下面是随便罗列的几个，因此放弃这个方法. 123EXP-00113: Feature New Composite Partitioning Method is unsupported. EXP-00107: Feature (BINARY XML) of column XML_CONTENT in tableORA-00904: &quot;DUMMYFLAG&quot;: invalid identifier 方法二：expdp和impdp（不推荐）经历方法一的失败，网上看到有数据泵的方式，因此再次尝试 1. 环境&amp;资料使用数据泵需要10g以上的oracle server版本，同时需要在服务端运行，相关的教程建议看 https://hevodata.com/learn/export-data-from-oracle-using-expdp/#i1 https://docs.oracle.com/cd/E11882_01/server.112/e22490/dp_export.htm#SUTIL200 https://oracle-base.com/articles/10g/oracle-data-pump-10g#TableExpImp 2. 使用方法连接本地数据库 1sqlplus &#x2F; as sysdba 创建连接远程数据库(本地的话不需用)(网上很多教程没有提到这一步，如果不创建，生成的dmp文件在远程的oracle服务器上) 1SQL&gt;create public database link orcl11g connect to system identified by oracle using &#x27;(DESCRIPTION =(ADDRESS_LIST =(ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.0.2)(PORT = 1521)))(CONNECT_DATA =(SERVICE_NAME = test)))&#x27;; 创建dmp文件本地存储路径，并赋予权限 12SQL&gt;create directory data_dir as &#x27;/home/oracle/back/data&#x27;;SQL&gt;Grant read,write on directory data_dir to test; shell下，导出数据(有多种导出模式：导整个数据库、按表空间导、按用户导、按表名导、按查询条件导) 12mkdir -p /home/oracle/back/dataexpdp system/system dumpfile=export.dmp directory=data_dir network_link=orcl11g schemas=test 导入数据（注意：需要先建表空间、用户，即使按整个数据库模式） 1impdp test/*** dumpfile=export.dmp directory=data_dir schemas=test 3. 问题用了方法二，问题同样很多，有些报错解决不了。因此这个方法也放弃 123ORA-14460ORA-26059....... 方法三: 写脚本也试过用plsql的导出用户对象、导出表的方式，但也是动不动就出问题，而且无法实现自动化，想要灵活的定制只能自己写脚本同步数据。下面是相关代码， 工具：python 1. 整体代码结构123456789101112131415161718192021222324252627282930import cx_Oracleimport osg_table_space_name_list = [[&#x27;TEST1_DATA&#x27;, &#x27;test1dat.dbf&#x27;, 1024], [&#x27;TEST2_DATA&#x27;, &#x27;test2dat.dbf&#x27;, 1024]] grant_privilege = [&quot;CONNECT&quot;,&quot;RESOURCE&quot;,&quot;DBA&quot;,&quot;UNLIMITED TABLESPACE&quot;, &quot;select any table&quot;,&quot;create any table&quot;, &quot;drop any table&quot;]g_user_name_list = [[&quot;LJ_TEST&quot;, &quot;TEST1_DATA&quot;, grant_privilege], [&quot;LJ_TEST2&quot;, &quot;LJ_TEST2&quot;, grant_privilege]]exist_table_space_str = &quot;select count(*) from dual where exists(&quot; \\ &quot;select * from v$tablespace a where a.name = upper(&#x27;%s&#x27;))&quot;create_table_space_str = &quot;CREATE TABLESPACE %s DATAFILE &quot; \\ &quot;&#x27;/home/oracle/app/oracle/oradata/helowin/%s&#x27; &quot; \\ &quot;SIZE %dM EXTENT MANAGEMENT LOCAL SEGMENT SPACE MANAGEMENT AUTO&quot;exist_user_name_str = &quot;select count(*) from dual where exists(&quot; \\ &quot;select * from all_users a where a.username = upper(&#x27;%s&#x27;))&quot;create_user_name_str = &quot;CREATE USER %s IDENTIFIED BY test &quot; \\ &quot;DEFAULT TABLESPACE %s TEMPORARY TABLESPACE TEMP&quot;query_table_data_str = &quot;select * from %s.%s&quot;insert_table_data_str = &quot;insert into %s.%s (%s) values (%s)&quot;delete_table_data_str = &quot;truncate table %s.%s&quot;if __name__ == &#x27;__main__&#x27;: client = OracleClient() client.create_table_space() client.create_user_name() client.create_table() client.sync_data() 2.连接数据库12345678910111213141516class OracleClient: def __init__(self): os.environ[&#x27;NLS_LANG&#x27;] = &#x27;SIMPLIFIED CHINESE_CHINA.utf8&#x27; # 待同步的数据库 dsn = cx_Oracle.makedsn(&quot;192.168.0.1&quot;, &#x27;1521&#x27;, service_name=&#x27;test&#x27;) self.m_client = cx_Oracle.connect(&#x27;system&#x27;, &#x27;oracle&#x27;, dsn) self.m_cursor = self.m_client.cursor() # 数据源 src_dsn = cx_Oracle.makedsn(&quot;192.168.0.2&quot;, &#x27;1521&#x27;, service_name=&#x27;test&#x27;) self.m_src_client = cx_Oracle.connect(&#x27;system&#x27;, &#x27;oracle&#x27;, src_dsn) self.m_src_cursor = self.m_src_client.cursor() def __del__(self): self.m_cursor.close() self.m_client.close() self.m_src_cursor.close() self.m_src_client.close() 3. 建立表空间12345678910def create_table_space(self): for table_space_name in g_table_space_name_list: self.m_cursor.execute(exist_table_space_str % table_space_name[0]) data = self.m_cursor.fetchall() # todo: if table space created, should drop and recreate. if data[0][0] != 0: continue self.m_cursor.execute(create_table_space_str % (table_space_name[0], table_space_name[1], table_space_name[2])) self.m_client.commit() 4. 建用户123456789101112def create_user_name(self): for user_name in g_user_name_list: self.m_cursor.execute(exist_user_name_str % user_name[0]) data = self.m_cursor.fetchall() # todo: if user created, should drop and recreate. if data[0][0] != 0: continue self.m_cursor.execute(create_user_name_str % (user_name[0], user_name[1])) for privilege in user_name[2]: self.m_cursor.execute(&quot;GRANT %s TO %s&quot; % (privilege, user_name[0])) self.m_client.commit() 5. 建表1234567891011121314151617181920212223242526272829 def _get_table_name_list(self): src_table_name_list = &#123;&#125; dst_table_name_list = &#123;&#125; for user_name in g_user_name_list: self.m_src_cursor.execute(query_table_name_str % user_name[0]) src_data = self.m_src_cursor.fetchall() src_table_name_list[user_name[0]] = [x[0] for x in src_data] self.m_cursor.execute(query_table_name_str % user_name[0]) data = self.m_cursor.fetchall() dst_table_name_list[user_name[0]] = [x[0] for x in data] return src_table_name_list, dst_table_name_list def _create_table(self, user_name, table_name): query_table_name_str = &quot;select TABLE_NAME from all_tables where OWNER = &#x27;%s&#x27;&quot;query_create_table_str=&quot;select dbms_metadata.get_ddl(&#x27;TABLE&#x27;,&#x27;%s&#x27;,&#x27;%s&#x27;) from dual&quot; self.m_src_cursor.execute(query_create_table_str % (table_name, user_name)) create_table_obj = self.m_src_cursor.fetchall() create_table_str = create_table_obj[0][0].read() self.m_cursor.execute(create_table_str) self.m_client.commit() def create_table(self): src_table_name_list, dst_table_name_list = self._get_table_name_list() for user_name in src_table_name_list: for table_name in src_table_name_list[user_name]: # todo, if table created, should recreated if table_name in dst_table_name_list[user_name]: continue self._create_table(user_name, table_name) 6. 同步数据123456789101112131415161718192021222324252627def _sync_data(self, user_name, table_name): self.m_src_cursor.execute(query_table_data_str % (user_name, table_name)) titles = &#x27;,&#x27;.join([i[0] for i in self.m_src_cursor.description]) data_placeholder = &#x27;,&#x27;.join([&#x27;:&#x27;+str(i+1) for i in range(len(self.m_src_cursor.description))]) try: all_table_data = self.m_src_cursor.fetchall() except cx_Oracle.DatabaseError as msg: print(&quot;\\033[1;31;40mError[%s.%s]:%s \\033[0m&quot; % (user_name, table_name, msg)) return # if contains old data,should drop self.m_cursor.execute(delete_table_data_str % (user_name, table_name)) self.m_client.commit() try: self.m_cursor.executemany(insert_table_data_str % ( user_name, table_name, titles, data_placeholder), all_table_data) except cx_Oracle.DatabaseError as msg: print(&quot;\\033[1;31;40mError[%s.%s]:%s \\033[0m&quot; % (user_name, table_name, msg)) return self.m_client.commit()def sync_data(self): src_table_name_list, dst_table_name_list = self._get_table_name_list() for user_name in src_table_name_list: for table_name in src_table_name_list[user_name]: if table_name not in dst_table_name_list[user_name]: self._create_table(user_name, table_name) self._sync_data(user_name, table_name)","categories":[],"tags":[]},{"title":"deployMonitor","slug":"deployMonitor","date":"2021-07-30T03:02:02.000Z","updated":"2021-07-30T03:02:02.000Z","comments":true,"path":"2021/07/30/deployMonitor/","link":"","permalink":"https://liji53.github.io/2021/07/30/deployMonitor/","excerpt":"","text":"数据监控方案背景&amp;预备知识​ 经过一个月多月的程序运行，数据沉淀在mongodb中，接下来就要考虑统计报表了，数据统计能最直接的体现你的工作价值！ ​ 从网上找了一些数据监控的解决方案，得益于docker的简单部署，让我们在验证方案可行性上省去了大量时间。整体方案：1.使用docker部署InfluxDb和Grafana；2.用influxDb远程连接Mongodb，并用脚本生成influxdb数据；3.最后通过Grafana的web展示出来。 ​ 预备知识： 了解InfluxDb，会使用python或其他语言读写influxdb数据库 了解Grafana，会简单使用对应的web即可 了解mongodb，由于数据源在mongodb，因此需要会从mongodb中读数据 环境部署1. 下载安装包下载地址： https://dl.grafana.com/oss/release/grafana-8.0.6-1.x86_64.rpm https://dl.influxdata.com/influxdb/releases/influxdb-1.7.10.x86_64.rpm 2. 生成docker镜像这里我把2个软件合成了一个镜像。 启动脚本文件run-tool.sh: 12service grafana-server startinfluxd -config /etc/influxdb/influxdb.conf dockerfile文件： 123456789101112131415FROM centos:7COPY influxdb-1.7.10.x86_64.rpm /home/COPY grafana-8.0.6-1.x86_64.rpm /home/COPY run-tool.sh /RUN cd /etc/yum.repos.d/ \\ &amp;&amp; curl -O http://mirrors.aliyun.com/repo/Centos-7.repo \\ &amp;&amp; rm CentOS-Base.repo; mv Centos-7.repo CentOS-Base.repo \\ &amp;&amp; yum clean all; yum makecache; yum -y update \\ &amp;&amp; yum install -y /sbin/service; yum install -y fontconfig \\ &amp;&amp; yum install -y urw-fonts \\ &amp;&amp; cd /home/ \\ &amp;&amp; rpm -ivh influxdb-1.7.10.x86_64.rpm \\ &amp;&amp; rpm -ivh grafana-8.0.6-1.x86_64.rpm \\ &amp;&amp; chmod +x /run-tool.shCMD /run-tool.sh 生成镜像命令： 1docker build -t tool:monitor . 3. 启动容器1docker run --name monitor --privileged -it -p 192.168.0.1:8086:8086 -p 192.168.0.1:3000:3000 -v /home/liji/docker/tmp:/mnt tool:monitor 验证是否部署成功，登录grafana的web界面查看，存在以下登录界面说明部署成功： 数据生成数据生成这个环节是粘合剂，把业务生成的数据通过某种规则转成直观的统计数据，是最核心的步骤。本环节我是通过python对mongodb里的数据进行统计，仅贴部分代码： 1. 连接mongodb、连接influxdb123456789import datetimeimport pymongofrom influxdb import InfluxDBClient# 连接mongodburl = &quot;mongodb://&quot; + g_mongo_ip + &#x27;:&#x27; + g_mongo_portmongo_client = pymongo.MongoClient(url)# 连接influxdbinflux_client = InfluxDBClient(g_influx_ip, g_influx_port, database=&#x27;test&#x27;)influx_client.create_database(g_influx_database) # 没有则创建 2. 统计mongodb的数据(DIY)12mongo_db = mongo_client[mongo_db_name]mongo_db[mongo_col_name].find(&#123;&quot;xxx&quot;: &#123;&quot;$exists&quot;: True&#125;&#125;).count() 3. 写入influxdb(DIY)123456789points = [&#123; &quot;measurement&quot;: mongo_db_name, &quot;time&quot;: datetime.datetime.utcnow().isoformat(&quot;T&quot;), &quot;fields&quot;: &#123; &quot;current_problem_count&quot;:100, &quot;resolve_problem_count&quot;:20 &#125; &#125;]influx_client.write_points(points) 4. 验证数据是否写入在安装了influxdb的环境中运行influx，具体命令可以百度 123456789[root@123106ce0db7 /]# influxConnected to http://localhost:8086 version 1.7.10InfluxDB shell version: 1.7.10&gt; show databases name: databasesname----_internaltest 界面展示这个环节是对grafana的界面操作，我也是刚入门，基本操作如下： 1. 配置数据源 选择influxdb以及选择连接地址端口 选择要连接的数据库，不用怕错误，点击“save &amp; test”的时候，会自动帮你测试连接情况 2. 配置展示面板 选择要展示的数据 3. 结果呈现这个效果是我的效果，暂时已经符合我的预期了哈 网上盗的图，参考 总结整个数据监控部署实现差不多花了2天半时间，在这个过程中让我第一次接触influxdb时间序列数据库，也第一次体验了数据监控的方案。作为开发，使用了你以前没用过的技术，确实很爽，但也要及时总结、温故而知新。","categories":[],"tags":[]},{"title":"花最小的学习成本部署web服务","slug":"deployWeb","date":"2021-07-05T11:51:02.000Z","updated":"2021-07-05T11:51:02.000Z","comments":true,"path":"2021/07/05/deployWeb/","link":"","permalink":"https://liji53.github.io/2021/07/05/deployWeb/","excerpt":"","text":"用httpd给程序搭个web界面当你写完程序，需要做推广时，必不可少的需要有个界面。基于这么一个简单背景，花了5天的时间，给自己的程序搞了个web界面，由于之前没有web的实战经验，又不能花大量精力在学习web上，因此有了这篇学习记录 预备知识主要储备知识还是在前端这块： 了解html、css、js，html和js可以在实际过程中边学边用 了解http协议，主要是出问题的时候，可以抓包快速确定是前端还是后端的问题 了解httpd、cgi，主要是要部署web服务器，以及写后端脚本 总体思路1.明确web做什么既然是花最小的学习成本部署web服务，那就需要清楚页面要做什么事，然后针对性的去学习。例如我这次web要做的是读写后台的配置文件。理想的服务端目录结构是这样的： 12345678&#123; &quot;系统1&quot;:&#123; &quot;子系统1&quot;:&#123; &quot;业务1&quot;:&quot;配置文件1&quot;, &quot;业务2&quot;:&quot;配置文件2&quot; &#125; &#125;&#125; web要修改的就是“配置文件1，配置文件2”。基于这个结构，web页面需要3层导航，分别表示 “系统”、‘’子系统“、“业务”，还需要一个能显示配置，同时能修改配置的地方。 2.找一个静态web页面模板找静态的web页面是为了让我们后续动态生成html有参考模板，同时网上的web页面会比自己从零开始写的要好看，不需要自己搞CSS。 3.部署服务器这里采用httpd作为服务器，使用cgi进行交互。httpd部署过程忽略(建议直接用docker) 4.确定交互协议找到合适的模板，部署好服务之后，就要考虑如何与服务器交互了，一般采用http协议，交互的数据格式为json。具体协议设计忽略 5.动态生成html页面这里主要是通过ajax来动态更新页面。 找静态web页面模板我的情况比较简单，只要能体现3层导航的web页面即可，可以从官网的demo中找 地址：https://getbootstrap.com/docs/5.0/getting-started/download/ 其他专业模板(太高端，没玩过)：https://www.w3cschool.cn/msv2es/qmaj1pyd.html 由于我没有经验，找了1个小时才找到合适的模板，模板长这样： 接着去掉内容，只留下html骨架代码。可以看到三个地方留了id属性，用于后续动态生成html 123456789101112131415161718192021&lt;!-- 最上面的导航 --&gt;&lt;div class=&quot;navbar navbar-fixed-top&quot;&gt; &lt;div class=&quot;navbar-inner&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;!-- id后面动态生成的时候用到 --&gt; &lt;div class=&quot;nav-collapse&quot; id=&#x27;header_system&#x27;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;row-fluid&quot;&gt; &lt;!-- 左边的导航栏 --&gt; &lt;div class=&quot;span3&quot;&gt; &lt;div class=&quot;well sidebar-nav&quot; id=&#x27;left_config&#x27;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 右边配置展示 --&gt; &lt;div class=&quot;span7&quot;&gt; &lt;div style=&quot;padding: 10px 10px 10px;&quot; id=&#x27;right_config&#x27;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 部署服务下载httpd的镜像，启动容器，命令如下： 123456docker pull centos/httpddocker run --name=myHttpd -it -p 192.168.0.1:8089:80 \\ -v /home/liji/apache/html:/var/www/html/ \\ -v /home/liji/apache/cgi-bin:/var/www/cgi-bin/ \\ -v /home/liji/apache/conf:/etc/httpd/conf \\ centos/httpd 修改httpd.conf，前面已经做好路径映射，直接修改/home/liji/apache/conf/httpd.conf 123456&lt;Directory &quot;/var/www/cgi-bin&quot;&gt; AllowOverride None SetHandler cgi-script Options ExecCGI Require all granted&lt;/Directory&gt; 重启httpd容器 1docker restart myHttpd cgi脚本可以用shell，也可以用python， 如果用python则还需要在容器内安装python，可以参考上一篇博客 测试CGI在html中随便加个能发请求的button，用于测试 1&lt;button type=&quot;button&quot; onclick=&quot;cgiHttp(&#x27;test&#x27;)&quot;&gt;测试CGI&lt;/button&gt; js发送请求代码如下： 1234567891011function cgiHttp(func)&#123; url = window.location.href + &#x27;cgi-bin/&#x27; + func + &#x27;.cgi&amp;arg=test&#x27; var request = new XMLHttpRequest() request.onreadystatechange = function() &#123; if (request.readyState==4 &amp;&amp; request.status==200)&#123; alert(request.responseText) &#125; &#125; request.open(&quot;GET&quot;, url, true) request.send(null)&#125; web服务端，在/home/liji/apache/cgi-bin目录下新建test.cgi，内容如下： 12345678import cgi, cgitbimport jsonform = cgi.FieldStorage()# 获取数据site_arg = form.getvalue(&#x27;arg&#x27;)print(&quot;Content-type:text/html&quot;)print()print(&quot;cgi test success! arg = %s&quot; % site_arg) 遇到问题的时候首先抓包，如果返回的是500内部服务错误，直接到/etc/httpd/logs/目录下，查看error_log文件 典型的3种错误有： 1.权限问题 1(13)Permission denied: exec of &#x27;/var/www/cgi-bin/test.cgi&#x27; failed 这种可能是test.cgi 没有执行权限，chmod +x test.cgi 解决 如果你写的cgi脚本需要修改其他目录下的文件，则还需要修改相应目录的权限，参考命令 chown -R apache:apache /home/test 2.执行失败 1(2)No such file or directory: exec of &#x27;/var/www/cgi-bin/previousPick.cgi&#x27; failed 检查test.cgi 是否存在windows字符，这个问题我当时花了半小时才找到。vi -b test.cgi，进入文件看有没有 ^M 字符 3.字符编码 1UnicodeEncodeError: &#x27;ascii&#x27; codec can&#x27;t encode characters in position 4-9: ordinal not in range(128) 这个问题比较恶心，在实际的环境中，脚本需要修改其他目录下的配置文件，而这个目录存在中文，就会报错。我用的是python3.6版本，直接运行脚本不会出错，但用apache用户运行就有问题，即使我在httpd.conf中加入环境变量SetEnv PYTHONIOENCODING utf-8依然没有解决，最后只能不用中文的目录来规避 协议交互假设现在设计了4个协议，对应服务端有4个脚本，分别是getSystem.cgi、getBusiness.cgi、getConfig.cgi、setConfig.cgi，js代码如下： 12345678910111213141516171819202122232425262728/// 根据协议的设计，拼装http请求，为了展示效果不冗余，只拼装1个协议function _get_url(func)&#123; url = window.location.href + &#x27;cgi-bin/&#x27; + func + &#x27;.cgi&#x27; if(func == &#x27;getSystem&#x27;)&#123; url += (&quot;?system=&quot; + g_system) &#125;else&#123; alert(&quot;功能尚未实现，敬请期待！&quot;) return null &#125; return url&#125;function cgiHttp(func)&#123; url = _get_url(func) if (url == null)&#123; return &#125; var request = new XMLHttpRequest() request.onreadystatechange = function() &#123; if (request.readyState==4 &amp;&amp; request.status==200)&#123; response_config = JSON.parse(request.responseText) /// 动态加载html页面 load_func = &#x27;_load&#x27; + func + &#x27;Response(response_config)&#x27; eval(load_func) &#125; &#125; request.open(&quot;GET&quot;, url, true) request.send(null)&#125; 动态更新页面根据前面的协议交互，我们已经能收到服务器的响应了，下面就是拼装html。先确定我们的目标长什么样： 1234567891011&lt;div class=&quot;nav-collapse&quot; id=&quot;header_system&quot;&gt; &lt;ul class=&quot;nav&quot;&gt; &lt;li class=&quot;active&quot; id=&quot;system_system1&quot;&gt; &lt;a onclick=&quot;systemClick(&#x27;system1&#x27;)&quot;&gt;system1&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;disabled&quot; id=&quot;system_system2&quot;&gt; &lt;a onclick=&quot;systemClick(&#x27;system2&#x27;)&quot;&gt;system2&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;disabled&quot; id=&quot;system_system3&quot;&gt; &lt;a onclick=&quot;systemClick(&#x27;system3&#x27;)&quot;&gt;system3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;p class=&quot;navbar-text pull-right&quot;&gt;contract liji37951&lt;/p&gt;&lt;/div&gt; 重点是class=”active” 、 id=”system_system1”、systemClick(‘system1’) 这几个字段是动态的。 1234567891011121314151617function _loadgetSystemResponse(systemConfig)&#123; headerInnerHtml = &#x27;&lt;ul class=&quot;nav&quot;&gt;&#x27; for (var i = 0; i &lt; systemConfig.length; i++)&#123; if (i == 0)&#123; headerInnerHtml += &#x27;&lt;li class=&quot;active&quot;&#x27; g_system = systemConfig[i] &#125;else&#123; headerInnerHtml += &#x27;&lt;li class=&quot;disabled&quot;&#x27; &#125; headerInnerHtml += &#x27; id=&quot;system_&#x27; + systemConfig[i] + &#x27;&quot;&gt;&lt;a onclick=&quot;systemClick(\\&#x27;&#x27; + systemConfig[i] + &#x27;\\&#x27;)&quot;&gt;&#x27; + _toChinese(systemConfig[i])+&#x27;&lt;/a&gt;&lt;/li&gt;&#x27; &#125; headerInnerHtml += &#x27;&lt;/ul&gt;&lt;p class=&quot;navbar-text pull-right&quot;&gt;contract liji&lt;/p&gt;&#x27; document.getElementById(&quot;header_system&quot;).innerHTML=headerInnerHtml&#125; 下面就是实现systemClick这个函数。 123456789function systemClick(system)&#123; if (document.getElementById(&quot;system_&quot;+system).className == &#x27;disabled&#x27;)&#123; document.getElementById(&quot;system_&quot;+g_system).className=&#x27;disabled&#x27; g_system = system document.getElementById(&quot;system_&quot;+system).className=&#x27;active&#x27; cgiHttp(&#x27;getBusiness&#x27;, g_system) cgiHttp(&#x27;getConfig&#x27;, g_business) &#125;&#125; 其他左边的导航栏，右边的配置内容， 方法是一致的。 总结这篇文章，无法直接拷贝代码，帮你完成web的搭建。但我写这篇文章，是为了下次遇到类似问题时提供一个思路，这次花5天时间搞定，下次能2天时间搞定，这就是这篇文章的价值。","categories":[],"tags":[]},{"title":"dockerBuild","slug":"dockerBuild","date":"2021-06-10T02:38:06.000Z","updated":"2021-06-10T02:38:06.000Z","comments":true,"path":"2021/06/10/dockerBuild/","link":"","permalink":"https://liji53.github.io/2021/06/10/dockerBuild/","excerpt":"","text":"定制docker镜像如果你写出来的应用，领导要求要考虑部署简单、可维护，这时候你应该想到docker，以我工作中的环境为例，部署需要用到httpd、mongodb、svn、python3等。但去hub docker上找相应的镜像，往往只能找到基础镜像，因此需要我们定制自己的镜像 。 准备工作1. 下载docker首先需要下载docker，我的环境是centos 7.6 由于是公司服务器环境，使用curl会连接失败，但好在yum能用 123456sudo yum install -y yum-utils device-mapper-persistent-data lvm2# 更新源地址sudo yum-config-manager --add-repo \\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo# 安装Docker Engine-Communitysudo yum install docker-ce docker-ce-cli containerd.io 安装完成之后，启动docker 1sudo systemctl start docker 2. 准备基础镜像我选的基础镜像是centos/httpd 1docker pull centos/httpd 但由于环境问题，会出现连接失败，因此需要手动打包镜像 先从能上网的地方下载镜像，比方先在windows上下载镜像，并打包 1234567C:\\Users\\liji&gt;docker pull centos/httpdC:\\Users\\liji&gt;docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEcentos latest 300e315adb2f 6 months ago 209MBliji1211/hexo V1 f03e20ea2889 11 months ago 289MBspurin/hexo latest f03e20ea2889 11 months ago 289MBcentos/httpd latest 2cc07fbb5000 2 years ago 258MB 12# 打包镜像C:\\Users\\liji&gt;docker save -o centos_httpd.tar 2cc07fbb5000 把本地打包的centos_httpd.tar 上传到服务器，并加载镜像 12# 加载镜像docker load -i centos_httpd.tar 定制镜像定制镜像，有2种方法: 第一种是基于基础镜像，在容器中直接修改下载各种软件，然后再把容器保存成镜像即可。另一种是通过Dockerfile来定制镜像，有点像写makefile，最后通过docker build来创建镜像。下面分别介绍： 使用Dockerfile定制 从网上下载mongodb的安装包，放在与Dockerfile同一级目录下 下载地址：https://www.mongodb.com/try/download/community?jmp=nav 新建Dockerfile，文件内容如下： 123456789101112131415161718FROM centos/httpdENV LANG en_US.UTF-8COPY mongodb-org-* /home/RUN mkdir /root/.pip/COPY pip.conf /root/.pip/RUN cd /etc/yum.repos.d/ \\ &amp;&amp; curl -O http://mirrors.aliyun.com/repo/Centos-7.repo \\ &amp;&amp; rm CentOS-Base.repo; mv Centos-7.repo CentOS-Base.repo \\ &amp;&amp; yum makecache; yum clean all; yum makecache; yum -y update \\ &amp;&amp; yum install -y openssl \\ &amp;&amp; yum install -y openssl-devel \\ &amp;&amp; yum install -y python36 \\ &amp;&amp; pip3 install lxml \\ &amp;&amp; yum install -y subversion \\ &amp;&amp; cd /home/ \\ &amp;&amp; rpm -ivh mongodb-org-server-4.0.24-1.el6.x86_64.rpm \\ &amp;&amp; rpm -ivh mongodb-org-shell-4.0.24-1.el6.x86_64.rpm \\ &amp;&amp; mkdir /home/data; mkdir /home/log; touch /home/log/mongod.log Dockerfile命令解释： FROM：指定基础镜像，会先从本地镜像仓库搜索，如果本地没有，则会网上搜索 ENV：设置系统环境变量 RUN：执行在系统里的命令，注意：有多条命令时，尽量写成一条命令 COPY：把本地文件拷贝到镜像里，这里pip.config内容如下 123[global]trusted-host=mirrors.aliyun.comindex-url=http://mirrors.aliyun.com/pypi/simple/ 构建镜像 1docker build -t test:v1 . 至此，一个安装了httpd、python3.6、mongodb、Svn的镜像就完成 手动修改容器镜像 基于前面的准备工作，我们先启动、进入容器 1docker run -it centos/httpd /bin/bash 进入容器之后，首先更新yum源 1234cd /etc/yum.repos.d/ curl -O http://mirrors.aliyun.com/repo/Centos-7.repo rm CentOS-Base.repo -f; mv Centos-7.repo CentOS-Base.repoyum makecache;yum clean all;yum makecache;yum -y update 下载openssl、python3.6、svn 1234yum install -y opensslyum install -y openssl-devel yum install -y python36yum install -y subversion 更新pip源 123456mkdir /root/.pip/cat &gt; /root/.pip/pip.conf &lt;&lt; EOF[global]trusted-host=mirrors.aliyun.comindex-url=http://mirrors.aliyun.com/pypi/simple/EOF 退出容器，按Ctrl+P，再按Ctrl+Q；然后把mongodb的安装包拷贝到容器中 123# 356e587e2f04是容器iddocker cp mongodb-org-server-4.0.24-1.el6.x86_64.rpm 356e587e2f04:/homedocker cp mongodb-org-shell-4.0.24-1.el6.x86_64.rpm 356e587e2f04:/home 再次进入容器，安装mongodb，并启动mongodb 123456789# 进入容器docker exec -it 356e587e2f04 /bin/bash# 安装mongodbcd /home/ rpm -ivh mongodb-org-server-4.0.24-1.el6.x86_64.rpm rpm -ivh mongodb-org-shell-4.0.24-1.el6.x86_64.rpm mkdir /home/data; mkdir /home/log; touch /home/log/mongod.log# 启动mongodb，但一旦重启容器、新建容器，mongodb需要重新启动mongod --dbpath /home/data/ --logpath /home/log/mongod.log --fork 退出容器，并制作镜像 1docker commit 356e587e2f04 test:v2 至此，镜像制作完成 比较2种方式1234[root@null mongo]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEtest v2 3cd3fd149fd0 45 seconds ago 1.17GBtest v1 150221daf971 4 hours ago 934MB dockerfile的优势： 镜像的体积会更小 可复用","categories":[],"tags":[]},{"title":"史上最详细-用docker部署博客","slug":"deployBlog","date":"2021-04-27T11:00:44.000Z","updated":"2021-04-27T11:00:44.000Z","comments":true,"path":"2021/04/27/deployBlog/","link":"","permalink":"https://liji53.github.io/2021/04/27/deployBlog/","excerpt":"","text":"用docker，hexo，github部署博客hexo+github的部署教程，网上详细教程一堆。如果你觉得安装node.js、npm以及再用npm安装各种模块(安装后还会有大量的安装残余)不爽，那欢迎参考本次教程。我们将使用docker来封装运行hexo，hexo镜像非自己制作，我们网上下载 预备知识通过本次教程，虽然可以完成搭建，但还是建议多储备点知识，这样在遇到环境差异时，能快速排查问题。 了解docker，会用常用命令；参考：https://www.runoob.com/docker/docker-tutorial.html 了解hexo，会用常用命令；参考：https://hexo.io/zh-cn/docs/ 了解git、github、markdown docker安装这里只讲win10安装docker，其他环境，请参考其他博客，网上资料很多，不怕搞不定 启用Hyper，Hyper是win10自带的虚拟化技术，docker会在Hyper虚拟出来的环境上运行 安装docker，下载地址：https://docs.docker.com/docker-for-windows/install/ 一路next即可 安装完成之后，cmd下执行docker version，如下所示，说明安装成功 1234567891011C:\\Users\\hspcadmin&gt;docker versionClient: Docker Engine - Community Cloud integration: 1.0.12 Version: 20.10.5 API version: 1.41 Go version: go1.13.15 Git commit: 55c4c88 Built: Tue Mar 2 20:14:53 2021 OS/Arch: windows/amd64 Context: default Experimental: true 修改镜像仓库的配置，最好自己申请一个阿里云的镜像，速度最快 docker启动hexohexo的镜像，从Docker官方的公共仓库找，网址：https://hub.docker.com/search?q=hexo 我选的是spurin/hexo (100K+下载量，说明用的人挺多的) 下载spurin/hexo镜像(我已经提前下载，所以打印提示已经是最新版本) 123456C:\\Users\\hspcadmin&gt;docker pull spurin/hexoUsing default tag: latestlatest: Pulling from spurin/hexoDigest: sha256:4f8a4d8133d5b29d60b86782237673511b3c3b2081b767064d2b922b53bc2ef5Status: Image is up to date for spurin/hexo:latestdocker.io/spurin/hexo:latest 创建容器，命令如图所示 12C:\\Users\\hspcadmin&gt;docker create --name=liji53.github.com -e HEXO_SERVER_PORT=4001 -e GIT_USER=&quot;liji53&quot; -e GIT_EMAIL=&quot;liji_1211@163.com&quot; -v E:/blog:/app -p 4001:4001 spurin/hexo666891af8d09cdc0443cfe157c3fcf10ab3f9739e72673cdf201a030c66d4c75 详细参数说明： –name 给容器指定名称，方便多个博客的管理(非必须) -e HEXO_SERVER_PORT 指定hexo server的端口(注意这个是容器内部的hexo server端口) -e GIT_USER github账户的账户名称(必须与github上的账号保持一致，还没有的赶紧注册) -e GIT_EMAIL github的注册email -v 路径映射，把hexo的app文件夹映射到本地 -p 将容器内部使用的网络端口随机映射到我们使用的主机上 启动容器，需要一段时间。会自动初始化hexo、下载依赖的插件、创建SSH密钥等。(启动的打印很多，我这里仅展示部分) 123456789101112C:\\Users\\hspcadmin&gt;docker start liji53.github.com &amp;&amp; docker logs --follow liji53.github.comliji53.github.com***** App directory exists and has content, continuing ********** App directory contains a requirements.txt file, installing npm requirements ********** App .ssh directory exists and has content, continuing ********** Running git config, user = liji53, email = liji_1211@163.com ********** Copying .ssh from App directory and setting permissions ********** Contents of public ssh key (for deploy) - ********** Starting server on port 4001 *****INFO Validating configINFO Start processingINFO Hexo is running at http://localhost:4001 . Press Ctrl+C to stop. 检查–本地预览效果，出现以下图片说明部署成功了 ，网址：http://localhost:4001/ 替换hexo主题hexo的主题，我们用的是hueman，地址：https://github.com/ppoffice/hexo-theme-hueman 进入容器（也可以不进入容器，后续步骤可直接在windows的映射路径上操作） 12C:\\Users\\hspcadmin&gt;docker exec -it liji53.github.com bashroot@666891af8d09:/app# 下载主题 123456789root@666891af8d09:/app/themes# git clone https://github.com/ppoffice/hexo-theme-hueman.git themes/huemanCloning into &#x27;themes/hueman&#x27;...remote: Enumerating objects: 2272, done.remote: Counting objects: 100% (11/11), done.remote: Compressing objects: 100% (11/11), done.remote: Total 2272 (delta 1), reused 2 (delta 0), pack-reused 2261Receiving objects: 100% (2272/2272), 5.77 MiB | 37.00 KiB/s, done.Resolving deltas: 100% (1216/1216), done.Checking out files: 100% (241/241), done. 如果出现下面这个问题(fatal: unable to access ‘https://github.com/ppoffice/hexo-theme-hueman.git/&#39;: gnutls_handshake() failed: The TLS connection was non-properly terminated.) 则该改成 1git clone git://github.com/ppoffice/hexo-theme-hueman.git themes/hueman 修改hueman的默认配置名称 1root@666891af8d09:/app# mv themes/hueman/_config.yml.example themes/hueman/_config.yml 修改hexo的全局配置，使用hueman的主题，在windows上修改，本例的文件路径是E:\\blog\\_config.yml（在容器中修改，没有vim，需要下载，下载命令 apt update &amp;&amp; apt -y install vim） 打开_config.yml，找到theme这一行，改成hueman，其他_config.yml的用法参考官网 https://hexo.io/zh-cn/docs/configuration 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: hueman 检查–本地预览效果，出现以下图片说明部署成功了，网址：http://localhost:4001/ 如果效果不对，试试重启容器，命令： 1docker restart liji53.github.com &amp;&amp; docker logs --follow liji53.github.com 搭建github博客首先，要注册一个github的账号，注册的邮箱必须要验证，这步就不贴图了 创建仓库 仓库的名字必须是username.github.io，其中username是你的用户名 配置SSH Key当你本地写完博客，提交代码时，必须有github权限才可以，直接使用用户名和密码每次都要输入，很不方便。因此我们使用ssh key来解决这个问题 前面搭建docker+hexo的过程中，已经提到hexo容器帮我们生成了ssh密钥，不需要调用ssh-keygen 密钥的路径在本地映射路径下，参考： 记事本打开.ssh\\id_rsa.pub文件，复制里面的内容，打开你的github主页，进入个人设置-&gt;SSH and GPG keys -&gt; New SSH key, 将刚复制的内容粘贴到key哪里，title随便填 用hexo写博客并上传到这一步，环境已经搭建完成了，只剩考虑该写啥了。。。接下来我们简单验证下 在容器环境下，用命令生成文件；在到windows环境下，打开test.md随便写几句 123root@666891af8d09:/app# hexo new testINFO Validating configINFO Created: /app/source/_posts/test.md 进入容器，用hexo生成博客静态网页(会生成public目录，里面就是生成的网页) 1234567891011root@666891af8d09:/app# hexo gINFO Validating configINFO Start processingDeprecated as of 10.7.0. highlight(lang, code, ...args) has been deprecated.Deprecated as of 10.7.0. Please use highlight(code, options) instead.https://github.com/highlightjs/highlight.js/issues/2277INFO Files loaded in 2.6 sINFO Generated: content.jsonINFO Generated: archives/index.htmlINFO Generated: archives/2021/index.htmlINFO Generated: index.html 上传博客(用hexo d命令只会上传public目录，其他不会上传) 123456789root@666891af8d09:/app# hexo dINFO Validating configINFO Start processingDeprecated as of 10.7.0. highlight(lang, code, ...args) has been deprecated.Deprecated as of 10.7.0. Please use highlight(code, options) instead.https://github.com/highlightjs/highlight.js/issues/2277INFO Files loaded in 2.48 sINFO Generated: content.jsonINFO Generated: archives/index.html 检查–网站预览效果 常见问题及参考 github访问慢、访问失败 参考：https://zhuanlan.zhihu.com/p/15893854 博客图片路径加载失败 参考：https://blog.csdn.net/xjm850552586/article/details/84101345 其他参考 https://spurin.com/2020/01/04/Creating-a-Blog-Website-with-Docker-Hexo-Github-Free-Hosting-and-HTTPS/ https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html","categories":[],"tags":[]}],"categories":[],"tags":[]}