<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />

    

    
    <title>os-并发 | 么么博客</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="keywords" content="" />
    
    <meta name="description" content="并发并发、互斥、同步在实际开发过程中经常会用到，本文将聚焦于互斥与同步，除了了解底层的互斥原理，还将重点学习glic提供的几种互斥机制。 底层原子操作原子操作：将多个步骤合成一个操作，这个操作要么成功，要么失败。底层原子操作由硬件提供，在阅读同步相关的源码时，会经常看到类似atomic_compare_exchange，atomic_fetch_add等类似的函数，其实这些函数就是封装了这些底层的">
<meta property="og:type" content="article">
<meta property="og:title" content="os-并发">
<meta property="og:url" content="https://liji53.github.io/2021/06/29/operatingSystem/os-concurrency/index.html">
<meta property="og:site_name" content="么么博客">
<meta property="og:description" content="并发并发、互斥、同步在实际开发过程中经常会用到，本文将聚焦于互斥与同步，除了了解底层的互斥原理，还将重点学习glic提供的几种互斥机制。 底层原子操作原子操作：将多个步骤合成一个操作，这个操作要么成功，要么失败。底层原子操作由硬件提供，在阅读同步相关的源码时，会经常看到类似atomic_compare_exchange，atomic_fetch_add等类似的函数，其实这些函数就是封装了这些底层的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://liji53.github.io/2021/06/29/operatingSystem/os-concurrency/Images/futex_struct.png">
<meta property="article:published_time" content="2021-06-29T15:54:28.000Z">
<meta property="article:modified_time" content="2021-06-29T15:54:28.000Z">
<meta property="article:author" content="Liji">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://liji53.github.io/2021/06/29/operatingSystem/os-concurrency/Images/futex_struct.png">
    

    
        <link rel="alternate" href="https://github.com/liji53/liji53.github.io" title="么么博客" type="application/atom+xml" />
    

    

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/libs/titillium-web/styles.css">

    
<link rel="stylesheet" href="/libs/source-code-pro/styles.css">


    
<link rel="stylesheet" href="/css/style.css">


    
<script src="/libs/jquery/3.5.0/jquery.min.js"></script>

    
    
        
<link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">

    
    
        
<link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">

    
    
    
    


<meta name="generator" content="Hexo 5.4.0"></head>

<body>
    <div id="wrap">
        <header id="header">
    <div id="header-outer" class="outer">
        <div class="container">
            <div class="container-inner">
                <div id="header-title">
                    <h1 class="logo-wrap">
                        <a href="/" class="logo"></a>
                    </h1>
                    
                </div>
                <div id="header-inner" class="nav-container">
                    <a id="main-nav-toggle" class="nav-icon fa fa-bars"></a>
                    <div class="nav-container-inner">
                        <ul id="main-nav">
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/">主页</a>
                                </li>
                            
                                    <ul class="main-nav-list"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/C-%E5%9F%BA%E7%A1%80/">C++基础</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/python%E6%9D%82%E9%A1%B9/">python杂项</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/%E7%BC%96%E8%AF%91%E3%80%81%E6%B1%87%E7%BC%96%E3%80%81%E9%93%BE%E6%8E%A5/">编译、汇编、链接</a></li></ul>
                                
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/about/index.html">关于</a>
                                </li>
                            
                        </ul>
                        <nav id="sub-nav">
                            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>


</div>
                        </nav>
                    </div>
                </div>
            </div>
        </div>
    </div>
</header>

        <div class="container">
            <div class="main-body container-inner">
                <div class="main-body-inner">
                    <section id="main">
                        <div class="main-body-header">
    <h1 class="header">
    
    <a class="page-title-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
    </h1>
</div>

                        <div class="main-body-content">
                            <article id="post-operatingSystem/os-concurrency" class="article article-single article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
        os-并发
        </h1>
    

            </header>
        
        
            <div class="article-meta">
                
  <div class="article-date">
    <i class="fa fa-calendar"></i>
    <a href="/2021/06/29/operatingSystem/os-concurrency/" class="article-date">
       <time datetime="2021-06-29T15:54:28.000Z" itemprop="datePublished">2021-06-29</time>
    </a>
  </div>


<div class="article-date">
  <i class="fa fa-calendar-plus-o"></i>
  <a href="/2021/06/29/operatingSystem/os-concurrency/" class="article-date">
     <time datetime="2021-06-29T15:54:28.000Z" itemprop="dateModified">2021-06-29</time>
  </a>
</div>


                

                
                

                

            </div>
        
        
        <div class="article-entry" itemprop="articleBody">
            

            

            

            <h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>并发、互斥、同步在实际开发过程中经常会用到，本文将聚焦于互斥与同步，除了了解底层的互斥原理，还将重点学习glic提供的几种互斥机制。</p>
<h3 id="底层原子操作"><a href="#底层原子操作" class="headerlink" title="底层原子操作"></a>底层原子操作</h3><p>原子操作：将多个步骤合成一个操作，这个操作要么成功，要么失败。<br>底层原子操作由硬件提供，在阅读同步相关的源码时，会经常看到类似atomic_compare_exchange，atomic_fetch_add等类似的函数，其实这些函数就是封装了这些底层的原子操作指令。<br>因此熟悉这部分原子操作对阅读理解pthread相关的代码十分重要，下面我们看下4种基本的原子操作</p>
<h5 id="test-and-set"><a href="#test-and-set" class="headerlink" title="test-and-set"></a>test-and-set</h5><p>返回旧值，设置新值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TestAndSet</span><span class="params">(<span class="keyword">int</span> *ptr, <span class="keyword">int</span> <span class="keyword">new</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old = *ptr; <span class="comment">// fetch old value at ptr</span></span><br><span class="line">    *ptr = <span class="keyword">new</span>; <span class="comment">// store ’new’ into ptr</span></span><br><span class="line">    <span class="keyword">return</span> old; <span class="comment">// return the old value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="compare-and-swap"><a href="#compare-and-swap" class="headerlink" title="compare-and-swap"></a>compare-and-swap</h5><p>返回旧值，如果旧值与期望值一致，则设置新值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CompareAndSwap</span><span class="params">(<span class="keyword">int</span> *ptr, <span class="keyword">int</span> expected, <span class="keyword">int</span> <span class="keyword">new</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> actual = *ptr;</span><br><span class="line">    <span class="keyword">if</span> (actual == expected)</span><br><span class="line">        *ptr = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">return</span> actual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="fetch-and-add"><a href="#fetch-and-add" class="headerlink" title="fetch-and-add"></a>fetch-and-add</h5><p>返回旧值，更新值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FetchAndAdd</span><span class="params">(<span class="keyword">int</span> *ptr, <span class="keyword">int</span> add_value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old = *ptr;</span><br><span class="line">    *ptr = old + add_value;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用fetch-and-add我们可以实现基于ticket的自旋锁,ticket lock能保证执行顺序，实现先来先拿锁：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">lock_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ticket;</span><br><span class="line">    <span class="keyword">int</span> turn;</span><br><span class="line">&#125; <span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_init</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    lock-&gt;ticket = <span class="number">0</span>;</span><br><span class="line">    lock-&gt;turn = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> myturn = FetchAndAdd(&amp;lock-&gt;ticket, <span class="number">1</span>);   </span><br><span class="line">    <span class="keyword">while</span> (lock-&gt;turn != myturn)  </span><br><span class="line">        ; <span class="comment">// spin</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    FetchAndAdd(&amp;lock-&gt;turn, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="load-和-store"><a href="#load-和-store" class="headerlink" title="load 和 store"></a>load 和 store</h5><p>load指每次读最新的值<br>store如果没有人写ptr则更新ptr，并返回成功，否则返回失败</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LoadLinked</span><span class="params">(<span class="keyword">int</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StoreConditional</span><span class="params">(<span class="keyword">int</span> *ptr, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (如果没有人更新ptr) &#123;</span><br><span class="line">        *ptr = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// success!</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// failed to update</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>了解了硬件提供的几种原子操作之后，我们可以基于这些原子操作实现一些互斥功能。<br>首先来看下mutex，但在看它的实现之前，我么需要清楚如何评估一个锁的好坏，主要从下面2方面考虑：</p>
<ol>
<li>公平性，主要看是否可能存在“饥饿”现象</li>
<li>性能，从实际环境来评估：cpu是否多核，线程数，临界区的长度</li>
</ol>
<h5 id="1-自旋锁"><a href="#1-自旋锁" class="headerlink" title="1.自旋锁"></a>1.自旋锁</h5><p>这个实现比较简单，利用前面的4种原子操作都能实现，如利用compare-and-swap：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (CompareAndSwap(&amp;lock-&gt;flag, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        ; <span class="comment">// spin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面重点看下它的优劣势：<br>从公平性角度来看，可能存在饥饿现象。（除了上面基于ticket 的spin lock）<br>从性能角度来看，对于单核cpu来说，采用自旋的锁，必然是浪费cpu的，参考<a href="https://liji53.github.io/2021/06/15/operatingSystem/os-virtualization/">虚拟cpu</a>的进程调度<br>但是对于多核的cpu来说（线程数接近cpu核数），如果临界区很短(立马就释放锁)，采用自旋锁，性能将比普通的锁更好</p>
<h5 id="2-nptl互斥锁的实现"><a href="#2-nptl互斥锁的实现" class="headerlink" title="2.nptl互斥锁的实现"></a>2.nptl互斥锁的实现</h5><p>自旋锁会一直占用cpu，浪费资源，如何让出cpu，让程序更高效。下面我们通过glibc的源码，来看下pthread_mutex的锁实现，<br>pthread_mutex_lock的近似代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __pthread_mutex_lock (<span class="keyword">pthread_mutex_t</span> *mutex)&#123;</span><br><span class="line">    <span class="comment">// 普通锁</span></span><br><span class="line">    <span class="keyword">if</span> (type == PTHREAD_MUTEX_TIMED_NP)&#123;</span><br><span class="line">        <span class="built_in">LLL_MUTEX_LOCK</span>(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 嵌套锁/递归锁，允许同一个线程多次加锁</span></span><br><span class="line">    <span class="built_in">elif</span> (type == PTHREAD_MUTEX_RECURSIVE_NP)&#123;</span><br><span class="line">        <span class="keyword">pid_t</span> id = <span class="built_in">THREAD_GETMEM</span>(THREAD_SELF, tid);  <span class="comment">// 获取线程id</span></span><br><span class="line">        <span class="keyword">if</span> (mutex-&gt;__data.__owner == id)&#123;<span class="keyword">return</span>;&#125;  <span class="comment">// 已经持有锁直接返回</span></span><br><span class="line">        <span class="built_in">LLL_MUTEX_LOCK</span>(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 适应锁，跟自旋锁类似，尝试获取，但过一段时间仍然获取不到，就放弃，并让出CPU</span></span><br><span class="line">    <span class="built_in">elif</span> (type == PTHREAD_MUTEX_ADAPTIVE_NP)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">LLL_MUTEX_TRYLOCK</span> (mutex) != <span class="number">0</span>)&#123;            </span><br><span class="line">            <span class="keyword">do</span>&#123;  <span class="comment">// 一直尝试获取</span></span><br><span class="line">                <span class="keyword">if</span> (++cnt &gt; max_cnt)&#123;  <span class="comment">// 过一段时间仍然获取不到，则放弃，让出CPU</span></span><br><span class="line">                    <span class="built_in">LLL_MUTEX_LOCK</span>(mutex);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">while</span>(<span class="built_in">LLL_MUTEX_TRYLOCK</span>(mutex) != <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// PTHREAD_MUTEX_ERRORCHECK_NP 检错锁，如果一个线程2次获取同一个锁则，返回失败</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">pid_t</span> id = <span class="built_in">THREAD_GETMEM</span> (THREAD_SELF, tid);</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (mutex-&gt;__data.__owner == id))&#123;<span class="keyword">return</span> EDEADLK;&#125;</span><br><span class="line">        <span class="built_in">LLL_MUTEX_LOCK</span>(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码里清楚的展示了4种锁的上层实现策略，而最关键的LLL_MUTEX_LOCK代码，我们下面讲</p>
<h5 id="3-futex机制"><a href="#3-futex机制" class="headerlink" title="3.futex机制"></a>3.futex机制</h5><p>先简单介绍下futex，futex机制在linux2.5.7之后开始使用(fast Userspace mutexes)。<br>它的主要优势是在加锁的时候根据共享内存里的futex变量，判断该变量是否有竞争，如果没有竞争则通过原子操作把共享的futex变量置1，这样不需要进入内核态，就可以完成加锁了。<br>而如果有竞争则执行系统调用futex_wait，将需要等待的进程(线程)加入到futex的等待队列中，直到通过futex_wake进行唤醒。<br>futex的结构维护在内核中.它的数据结构大概如下：<br><img src="/2021/06/29/operatingSystem/os-concurrency/Images/futex_struct.png"><br>加入等待队列以及唤醒的基本接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//uaddr代表futex word的地址，val代表这个地址期待的值，当*uaddr==val时，才会进行wait</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">futex_wait</span><span class="params">(<span class="keyword">int</span> *uaddr, <span class="keyword">int</span> val)</span></span>;</span><br><span class="line"><span class="comment">//唤醒n个在uaddr指向的锁变量上挂起等待的进程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">futex_wake</span><span class="params">(<span class="keyword">int</span> *uaddr, <span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<p>因此前面pthread_mutex_lock的LLL_MUTEX_LOCK函数如下（参考lowlevellock.h）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void LLL_MUTEX_LOCK(pthread_mutex_t *mutex)&#123;</span><br><span class="line">    &#x2F;&#x2F; CAS原子操作，如果等于0则置为1，表示没有锁竞争</span><br><span class="line">    &#x2F;&#x2F; mutex-&gt;__data.__lock 也就是所谓的futex word</span><br><span class="line">    if（atomic_compare_and_exchange_bool_acq(mutex-&gt;__data.__lock, 0, 1)）&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 有竞争，则阻塞，加入到futex等待队列</span><br><span class="line">    else&#123;</span><br><span class="line">        futex_wait(mutex-&gt;__data.__lock， 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>了解完futex的机制之后，我们再来评估下pthread_mutex的好坏：</p>
<ol>
<li>公平性：通过futex来管理等待线程，并不能保证它绝对的唤醒先后顺序，取决于OS的调度策略。</li>
<li>性能：无竞争时，不需要进程(线程)切换，性能极好；但存在锁冲突时，需要线程切换，存在性能浪费，但好在提供了自适应锁这种兼容spin lock优势的参数</li>
</ol>
<h5 id="4-nptl读写锁的实现"><a href="#4-nptl读写锁的实现" class="headerlink" title="4.nptl读写锁的实现"></a>4.nptl读写锁的实现</h5><p>在读操作频繁，写操作少的情况下，使用读写锁能提高性能，下面我们看下pthread中读写锁的实现(来自glibc-2.35)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">___pthread_rwlock_rdlock (<span class="keyword">pthread_rwlock_t</span> *rwlock)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 原子操作，让reader + 1</span></span><br><span class="line">    r = (atomic_fetch_add_acquire (&amp;rwlock-&gt;__data.__readers,</span><br><span class="line">			    (<span class="number">1</span> &lt;&lt; PTHREAD_RWLOCK_READER_SHIFT)) + (<span class="number">1</span> &lt;&lt; PTHREAD_RWLOCK_READER_SHIFT));</span><br><span class="line">    <span class="comment">// 如果当前为读阶段(即没有写)，则直接返回成功，不阻塞</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_likely ((r &amp; PTHREAD_RWLOCK_WRPHASE) == <span class="number">0</span>))&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="comment">// 如果处于写阶段，但并没有占有锁</span></span><br><span class="line">    <span class="keyword">while</span> ((r &amp; PTHREAD_RWLOCK_WRPHASE) != <span class="number">0</span> &amp;&amp; (r &amp; PTHREAD_RWLOCK_WRLOCKED) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 尝试改成读阶段</span></span><br><span class="line">        <span class="keyword">if</span> (atomic_compare_exchange_weak_acquire (&amp;rwlock-&gt;__data.__readers, &amp;r, r ^ PTHREAD_RWLOCK_WRPHASE))&#123;</span><br><span class="line">            <span class="comment">// 更新写阶段的futex变量，设置为0意味着解锁</span></span><br><span class="line">            <span class="keyword">if</span> ((atomic_exchange_relaxed (&amp;rwlock-&gt;__data.__wrphase_futex, <span class="number">0</span>) &amp; PTHREAD_RWLOCK_FUTEX_USED) != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 唤醒其他阻塞的读线程</span></span><br><span class="line">                <span class="keyword">int</span> <span class="keyword">private</span> = __pthread_rwlock_get_private (rwlock);</span><br><span class="line">                futex_wake (&amp;rwlock-&gt;__data.__wrphase_futex, INT_MAX, <span class="keyword">private</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">// 不停的重新尝试&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 处于写阶段，并且锁已经被其他线程占有</span></span><br><span class="line">        <span class="keyword">while</span> (((wpf = atomic_load_relaxed (&amp;rwlock-&gt;__data.__wrphase_futex))</span><br><span class="line">	            | PTHREAD_RWLOCK_FUTEX_USED) == (<span class="number">1</span> | PTHREAD_RWLOCK_FUTEX_USED))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="keyword">private</span> = __pthread_rwlock_get_private (rwlock);</span><br><span class="line">            <span class="comment">// 如果中途 锁已经释放了</span></span><br><span class="line">            <span class="keyword">if</span> (((wpf &amp; PTHREAD_RWLOCK_FUTEX_USED) == <span class="number">0</span>) &amp;&amp; (!atomic_compare_exchange_weak_relaxed</span><br><span class="line">	                (&amp;rwlock-&gt;__data.__wrphase_futex, &amp;wpf, wpf | PTHREAD_RWLOCK_FUTEX_USED)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 继续尝试，看锁是否又被写进程占有了</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// futex_wait,加入到futex的等待队列</span></span><br><span class="line">            <span class="keyword">int</span> err = __futex_abstimed_wait64 (&amp;rwlock-&gt;__data.__wrphase_futex,</span><br><span class="line">					<span class="number">1</span> | PTHREAD_RWLOCK_FUTEX_USED, clockid, abstime, <span class="keyword">private</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码如果理解有困难，可以参考下面读写锁各个阶段的情况：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WP 指的是读写阶段他，WL 指的是写锁， R 指的是读的线程数(也代表读锁)， RW 指的是是否有读线程在等待</span></span><br><span class="line">   State WP  WL  R   RW  Notes</span><br><span class="line">   ---------------------------</span><br><span class="line">   #<span class="number">1</span>    <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="function">Lock is <span class="title">idle</span> <span class="params">(<span class="keyword">and</span> in a read phase)</span>.</span></span><br><span class="line">   #2    0   0   &gt;0  0   Readers have acquired the lock.    </span><br><span class="line">   #<span class="number">3</span>    <span class="number">0</span>   <span class="number">1</span>   <span class="number">0</span>   <span class="number">0</span>   Lock is <span class="keyword">not</span> acquired; a writer will <span class="keyword">try</span> to start a</span><br><span class="line">			 write phase.                                          </span><br><span class="line">   #<span class="number">4</span>    <span class="number">0</span>   <span class="number">1</span>   &gt;<span class="number">0</span>  <span class="number">0</span>   Readers have acquired the lock; a writer is waiting</span><br><span class="line">			 <span class="keyword">and</span> <span class="keyword">explicit</span> hand-over to the writer is required. </span><br><span class="line">   #<span class="number">4</span>a   <span class="number">0</span>   <span class="number">1</span>   &gt;<span class="number">0</span>  <span class="number">1</span>   Same as #<span class="number">4</span> except that there are further readers</span><br><span class="line">			 waiting because the writer is to be preferred.</span><br><span class="line">   #<span class="number">5</span>    <span class="number">1</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="function">Lock is <span class="title">idle</span> <span class="params">(<span class="keyword">and</span> in a write phase)</span>.</span></span><br><span class="line">   #6    1   0   &gt;0  0   Write phase; readers will try to start a read phase</span><br><span class="line">			 (<span class="keyword">requires</span> <span class="keyword">explicit</span> hand-over to all readers that</span><br><span class="line">			 <span class="keyword">do</span> <span class="keyword">not</span> start the read phase).</span><br><span class="line">   #<span class="number">7</span>    <span class="number">1</span>   <span class="number">1</span>   <span class="number">0</span>   <span class="number">0</span>   Lock is acquired by a writer.</span><br><span class="line">   #<span class="number">8</span>    <span class="number">1</span>   <span class="number">1</span>   &gt;<span class="number">0</span>  <span class="number">0</span>   Lock acquired by a writer <span class="keyword">and</span> readers are waiting;</span><br><span class="line">			 <span class="keyword">explicit</span> hand-over to the readers is required.</span><br></pre></td></tr></table></figure>
<p>注意：读不占用锁，只有写才占用锁，#3，#4，#4a 这三个阶段 为wrlock加锁的情况，需要等R的个数为0，才能进行写。<br>关于读写锁饿死的情况, 在rdlock源码中并没有看到处理，因此如果写频繁，请不要使用读写锁。<br>引用一句话“Big and dumb is better”，不要过分追求像读写锁这种听起来炫酷，但使用复杂的玩意。</p>
<h5 id="5-提高并发性能"><a href="#5-提高并发性能" class="headerlink" title="5.提高并发性能"></a>5.提高并发性能</h5><p>这里仅指优化锁的开销，从而提高并发性能<br>从前面的futex机制，我们知道如果出现锁冲突，就会有进程(线程)切换的开销(上下文切换、进程调度)，因此如何优化锁，核心在于减少锁的冲突：</p>
<ol>
<li>减少锁的持有时间，在锁的过程中不要使用会阻塞的接口，从时间颗粒度的角度考虑。</li>
<li>减少锁的空间颗粒度，将临界数据打散，每个分散后的临界数据各使用一把锁，代替全局的锁。因为数据分散之后，访问某一个数据的概率就减少了，锁冲突也就减少了。</li>
<li>避免使用锁,使用线程本地存储(比方TLS)。思路就是把临界数据变成线程局部数据，一段时间之后再更新回临界数据中。</li>
<li>在读操作频繁，写操作少的数据结构中，使用读写锁;在临界区短，冲突频繁的场景中使用自旋锁。</li>
<li>放弃用锁，使用wait-free的思路，比方使用无锁的数据结构。</li>
</ol>
<p>下面针对第二点，我们看下常见的数据结构如何从空间颗粒度角度，减少锁的开销：</p>
<ol>
<li>双向队列，使用2把锁代替1把锁<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">queue_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">node_t</span> *head;</span><br><span class="line">    <span class="keyword">node_t</span> *tail;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> headLock;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> tailLock;</span><br><span class="line">&#125; <span class="keyword">queue_t</span>;</span><br></pre></td></tr></table></figure></li>
<li>哈希表，每个哈希桶一把锁，哈希值不冲突就不会存在锁冲突<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">hash_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_t</span> lists[BUCKETS];</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> bucketLock[BUCKETS];</span><br><span class="line">&#125; <span class="keyword">hash_t</span>;</span><br></pre></td></tr></table></figure>
针对第三点采用TLS数据，看个多线程计数器的列子：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">counter_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> global; <span class="comment">// global count</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> glock; <span class="comment">// global lock</span></span><br><span class="line">    <span class="keyword">int</span> local[NUMCPUS]; <span class="comment">// 每个线程单独访问，不存在冲突</span></span><br><span class="line">    <span class="keyword">int</span> threshold; <span class="comment">// update frequency</span></span><br><span class="line">&#125; <span class="keyword">counter_t</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">counter_t</span> *c, <span class="keyword">int</span> threadID, <span class="keyword">int</span> amt)</span> </span>&#123;</span><br><span class="line">    c-&gt;local[threadID] += amt; <span class="comment">// assumes amt &gt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;local[threadID] &gt;= c-&gt;threshold) &#123; <span class="comment">// transfer to global</span></span><br><span class="line">        pthread_mutex_lock(&amp;c-&gt;glock);</span><br><span class="line">        c-&gt;global += c-&gt;local[threadID];</span><br><span class="line">        pthread_mutex_unlock(&amp;c-&gt;glock);</span><br><span class="line">        c-&gt;local[threadID] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>条件变量用于线程的同步，保证线程的执行先后顺序</p>
<h5 id="1-用法"><a href="#1-用法" class="headerlink" title="1.用法"></a>1.用法</h5><p>条件变量的使用虽然容易犯错，但它的套路其实比较固定的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景：A线程先执行，再执行B线程</span></span><br><span class="line"><span class="comment">// A线程：</span></span><br><span class="line">Pthread_mutex_lock(&amp;m);</span><br><span class="line">设置条件</span><br><span class="line">Pthread_cond_signal(&amp;c);</span><br><span class="line">Pthread_mutex_unlock(&amp;m);</span><br><span class="line"><span class="comment">// B线程：</span></span><br><span class="line">Pthread_mutex_lock(&amp;mutex); <span class="comment">// p1</span></span><br><span class="line"><span class="keyword">while</span> (条件不满足) <span class="comment">// p2</span></span><br><span class="line">    Pthread_cond_wait(&amp;cond, &amp;mutex); <span class="comment">// p3</span></span><br><span class="line">Pthread_mutex_unlock(&amp;mutex); <span class="comment">// p6</span></span><br></pre></td></tr></table></figure>
<p>常见的错误就是：</p>
<ol>
<li>没有和锁一起配合使用，或者锁顺序有问题，牢记条件变量要传锁的原因：即Pthread_cond_wait内部实现： 1.先释放锁，2.加入等待队列，3.唤醒之后再加锁</li>
<li>Pthread_cond_wait在等待条件满足时，不用while 而用if， Pthread_cond_wait可能存在虚假唤醒(被信号中断唤醒);也有可能同时唤醒2个线程，但另一个线程执行很快，又把值改回去了(ABA问题)</li>
<li>该使用2个条件变量，却只使用了一个条件变量，参考下面的消费者-生产者的错误模型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread__cond_t</span> cond;</span><br><span class="line"><span class="keyword">pthread__mutex_t</span> mutex;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        Pthread_mutex_lock(&amp;mutex); <span class="comment">// p1</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">1</span>) <span class="comment">// p2</span></span><br><span class="line">            Pthread_cond_wait(&amp;cond, &amp;mutex); <span class="comment">// p3</span></span><br><span class="line">        put(i); <span class="comment">// p4</span></span><br><span class="line">        Pthread_cond_signal(&amp;cond); <span class="comment">// p5</span></span><br><span class="line">        Pthread_mutex_unlock(&amp;mutex); <span class="comment">// p6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        Pthread_mutex_lock(&amp;mutex); <span class="comment">// c1</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) <span class="comment">// c2</span></span><br><span class="line">            Pthread_cond_wait(&amp;cond, &amp;mutex); <span class="comment">// c3</span></span><br><span class="line">        <span class="keyword">int</span> tmp = get(); <span class="comment">// c4</span></span><br><span class="line">        Pthread_cond_signal(&amp;cond); <span class="comment">// c5</span></span><br><span class="line">        Pthread_mutex_unlock(&amp;mutex); <span class="comment">// c6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这一段代码，如果只有1个消费者和1个生产者似乎没什么问题，但如果consumer(消费者)的线程数是2个就有问题了。<br>错误原因：如果consumer1 发出signal ，但唤醒的不是producer，而是consumer2，consumer2由于条件不满足，又睡眠了（并没有发signal），这时候三个线程就将永远睡眠。</li>
</ol>
<h5 id="2-生产者-消费者模型"><a href="#2-生产者-消费者模型" class="headerlink" title="2.生产者-消费者模型"></a>2.生产者-消费者模型</h5><p>正确的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cond_t</span> empty, fill;</span><br><span class="line"><span class="keyword">mutex_t</span> mutex;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        Pthread_mutex_lock(&amp;mutex); <span class="comment">// p1</span></span><br><span class="line">        <span class="keyword">while</span> (count == MAX) <span class="comment">// p2</span></span><br><span class="line">            Pthread_cond_wait(&amp;empty, &amp;mutex); <span class="comment">// p3</span></span><br><span class="line">        put(i); <span class="comment">// p4</span></span><br><span class="line">        Pthread_cond_signal(&amp;fill); <span class="comment">// p5</span></span><br><span class="line">        Pthread_mutex_unlock(&amp;mutex); <span class="comment">// p6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        Pthread_mutex_lock(&amp;mutex); <span class="comment">// c1</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) <span class="comment">// c2</span></span><br><span class="line">            Pthread_cond_wait(&amp;fill, &amp;mutex); <span class="comment">// c3</span></span><br><span class="line">        <span class="keyword">int</span> tmp = get(); <span class="comment">// c4</span></span><br><span class="line">        Pthread_cond_signal(&amp;empty); <span class="comment">// c5</span></span><br><span class="line">        Pthread_mutex_unlock(&amp;mutex); <span class="comment">// c6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-nptl的实现"><a href="#3-nptl的实现" class="headerlink" title="3.nptl的实现"></a>3.nptl的实现</h5><p>pthread_cond_wait的源码（来自glibc-2.35）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __pthread_cond_wait(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_mutex_t</span> *mutex)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// wseq低位是group的索引，因此需要加2才表示seq加1</span></span><br><span class="line">    <span class="keyword">uint64_t</span> wseq = __condvar_fetch_add_wseq_acquire (cond, <span class="number">2</span>);  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> g = wseq &amp; <span class="number">1</span>;  <span class="comment">// g是group[1]的索引</span></span><br><span class="line">    <span class="keyword">uint64_t</span> seq = wseq &gt;&gt; <span class="number">1</span>;   <span class="comment">// seq 为序列号</span></span><br><span class="line">    <span class="comment">// __wrefs 低3位有其他用处，+8 表示等待者计数 +1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags = atomic_fetch_add_relaxed (&amp;cond-&gt;__data.__wrefs, <span class="number">8</span>);</span><br><span class="line">    <span class="comment">// 【用户锁，解锁】</span></span><br><span class="line">    err = __pthread_mutex_unlock_usercnt (mutex, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 需要唤醒的等待者个数，__g_signals + g表示当前group</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> signals = atomic_load_acquire (cond-&gt;__data.__g_signals + g);</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果有信号</span></span><br><span class="line">            <span class="keyword">if</span> (signals != <span class="number">0</span>) &#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="comment">// __g_refs 当前组的引用计数+1</span></span><br><span class="line">            atomic_fetch_add_acquire (cond-&gt;__data.__g_refs + g, <span class="number">2</span>);</span><br><span class="line">            <span class="comment">// 【futex_wait 加入等待队列，阻塞】</span></span><br><span class="line">            err = __futex_abstimed_wait_cancelable64 (cond-&gt;__data.__g_signals + g, <span class="number">0</span>, clockid, abstime, <span class="keyword">private</span>);</span><br><span class="line">            <span class="comment">// 重新加载信号个数，被唤醒之后，signal有变化</span></span><br><span class="line">            signals = atomic_load_acquire (cond-&gt;__data.__g_signals + g);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前有需要唤醒的等待者，尝试获取signal</span></span><br><span class="line">    <span class="keyword">while</span> (!atomic_compare_exchange_weak_acquire (cond-&gt;__data.__g_signals + g, &amp;signals, signals - <span class="number">2</span>));</span><br><span class="line">    <span class="comment">// 当前group的起始序列号</span></span><br><span class="line">    <span class="keyword">uint64_t</span> g1_start = __condvar_load_g1_start_relaxed (cond);</span><br><span class="line">    <span class="comment">// 优先消费之前被wait的等待者，而不是本次的等待者</span></span><br><span class="line">    <span class="keyword">if</span> (seq &lt; (g1_start &gt;&gt; <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span> (((g1_start &amp; <span class="number">1</span>) ^ <span class="number">1</span>) == g)&#123;</span><br><span class="line">            <span class="comment">// 再次更新信号量</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> s = atomic_load_relaxed (cond-&gt;__data.__g_signals + g);</span><br><span class="line">            <span class="keyword">while</span> (__condvar_load_g1_start_relaxed (cond) == g1_start)&#123;</span><br><span class="line">                <span class="keyword">if</span> (((s &amp; <span class="number">1</span>) != <span class="number">0</span>) || atomic_compare_exchange_weak_relaxed(cond-&gt;__data.__g_signals + g, &amp;s, s + <span class="number">2</span>))&#123;</span><br><span class="line">                    <span class="comment">// 优先唤醒其他等待者</span></span><br><span class="line">                    futex_wake (cond-&gt;__data.__g_signals + g, <span class="number">1</span>, <span class="keyword">private</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">done:</span><br><span class="line">    <span class="comment">// 【用户锁，加锁】</span></span><br><span class="line">    err = __pthread_mutex_cond_lock (mutex);</span><br><span class="line">    <span class="keyword">return</span> (err != <span class="number">0</span>) ? err : result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码把异常处理、group的处理等都给省去了，即使如此，阅读这个代码可能依然有困难。<br>建议去glibc阅读源码（里面的注释很详细），搞清楚pthread_cond_t的每个字段的含义之后，阅读就轻松多了。<br>其实我们简化成以下伪代码就好理解了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_wait(<span class="keyword">cond_t</span>* t, <span class="keyword">mutex_t</span>* m)&#123;</span><br><span class="line">    unlock(m);</span><br><span class="line">    <span class="keyword">if</span>(atomic_load(t-&gt;futex_signal) == <span class="number">0</span>)&#123; <span class="comment">//如果signal为0，则进入等待队列</span></span><br><span class="line">        futex_wait(t-&gt;futex_signal, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    lock(m);</span><br><span class="line">&#125;</span><br><span class="line">pthread_cond_signal(<span class="keyword">cond_t</span>* t)&#123;</span><br><span class="line">    atmoic_ftech_and_add(t-&gt;futex_signal，<span class="number">1</span>);  <span class="comment">// signal 加1</span></span><br><span class="line">    futex_wake(t-&gt;futex_var, <span class="number">1</span>);  <span class="comment">// 唤醒一个等待者</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><h5 id="nptl中的实现"><a href="#nptl中的实现" class="headerlink" title="nptl中的实现"></a>nptl中的实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __new_sem_post (<span class="keyword">sem_t</span> *sem)&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> v = atomic_load_relaxed (&amp;isem-&gt;value);</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="comment">// 溢出</span></span><br><span class="line">        <span class="keyword">if</span> ((v &gt;&gt; SEM_VALUE_SHIFT) == SEM_VALUE_MAX)&#123;</span><br><span class="line">	        __set_errno (EOVERFLOW);</span><br><span class="line">	        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">/// 原子+1，如果有其他post导致value变换，则循环尝试</span></span><br><span class="line">    <span class="keyword">while</span> (!atomic_compare_exchange_weak_release(&amp;isem-&gt;value, &amp;v, v + (<span class="number">1</span> &lt;&lt; SEM_VALUE_SHIFT)));</span><br><span class="line">    <span class="comment">// 如果有等待的线程，则唤醒一个线程</span></span><br><span class="line">    <span class="keyword">if</span> ((v &amp; SEM_NWAITERS_MASK) != <span class="number">0</span>)</span><br><span class="line">        futex_wake (&amp;isem-&gt;value, <span class="number">1</span>, <span class="keyword">private</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>信号量的源码比读写锁、条件变量好理解多了。<br>将这些代码当作lock-free编程去学习，你再去网上的其他lock-free的数据结构也会轻松不少。</p>
<h3 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h3><h5 id="Non-Deadlock"><a href="#Non-Deadlock" class="headerlink" title="Non-Deadlock"></a>Non-Deadlock</h5><p>在实际软件项目中，非死锁导致的问题可能比死锁导致的问题更多，下面我们看看常见的两种非死锁并发问题：</p>
<ol>
<li>违背原子性：简单来说就是对于临界数据没有加锁</li>
<li>违背执行顺序：在多线程中由于执行顺序不正确导致的问题，通过条件变量、信号量 来保证同步就可以解决</li>
</ol>
<p>这类问题看起来很简单，但如果项目工程很大，在处理这些问题时，你需要对代码有较深入的理解才能解决。</p>
<h5 id="DeadLock"><a href="#DeadLock" class="headerlink" title="DeadLock"></a>DeadLock</h5><p>死锁产生的条件与解决方案：</p>
<ol>
<li>互斥：资源是独占的且排他使用<br>解决（实现复杂）：不使用互斥锁，而采用wait-free的方案。</li>
<li>请求和保持：进程每次申请它所需要的一部分资源，在申请新的资源的同时，继续占用已分配到的资源。<br>解决（会导致性能差）：在线程获取多个锁之前，先加一把大范围的锁。</li>
<li>不可剥夺：进程所获得的资源在未使用完毕之前，不被其他进程强行剥夺，而只能由获得该资源的进程资源释放。<br>解决（可读性差，异常处理复杂）：使用trylock，尝试获取锁，如果获取锁失败，则释放已经占用的锁，从而让其他进程能获取锁，但释放锁的时候需要考虑资源释放与重新申请的问题。</li>
<li>循环等待：比方A进程占用a锁，同时请求b锁，B进程占用b锁，请求a锁，导致AB进程互相等待<br>解决（最常用的方法）：保持获取锁的顺序一致。</li>
</ol>
<p>看完死锁的原因以及解决方案之后，并不能杜绝死锁的产生，究其原因，还是软件的复杂度导致的。<br>一般在软件设计中，组件之间的互相依赖、接口的封装 才是导致死锁的根本原因。<br>因此适当的接口使用说明、代码评审、测试覆盖以及代码漏洞检测，在提升软件质量上尤为关键</p>
<h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p>最后，我们简单看下进程与线程的区别：<br>进程是资源分配的基本单位，线程是CPU调度的基本单位。线程有独立的线程栈、寄存器。</p>
<p>在《Modern Operating Systems》中提到的线程模型：<br>在linux中pthread库中采用的是1对1的线程模型，即一个用户对应一个内核线程，内核负责每个线程的调度。<br>但这种一对一的模型存在用户态、内核态切换频繁的问题。<br>因此为提升效率，由用户实现支持多对一的定时器模型，能提高一定的效率，但这种模型调度的任务不能阻塞，否则会导致其他任务也不能执行。（之前在某公司做嵌入式开发时，就遇到过这个问题）<br><img src="/2021/06/29/operatingSystem/os-concurrency/Images/thread_module.png"></p>
<h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><p>书籍：<br>《Operating Systems: Three Easy Pieces》(<a target="_blank" rel="noopener" href="https://pages.cs.wisc.edu/~remzi/OSTEP/">线上书籍</a>)<br>《Modern Operating Systems》（第四版：有介绍futex,线程模型）<br>glibc源码地址：<br><a target="_blank" rel="noopener" href="http://ftp.gnu.org/gnu/glibc/">http://ftp.gnu.org/gnu/glibc/</a></p>

        </div>
        <footer class="article-footer">
            



    <a data-url="https://liji53.github.io/2021/06/29/operatingSystem/os-concurrency/" data-id="cl1zz9qep00011en47f1c6jl2" class="article-share-link"><i class="fa fa-share"></i>分享到</a>
<script>
    (function ($) {
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "author": {
            "@type": "Person",
            "name": "Liji"
        },
        "headline": "os-并发",
        "image": "https://liji53.github.io/2021/06/29/operatingSystem/os-concurrency/Images/futex_struct.png",
        "keywords": "",
        "genre": "操作系统",
        "datePublished": "2021-06-29",
        "dateCreated": "2021-06-29",
        "dateModified": "2021-06-29",
        "url": "https://liji53.github.io/2021/06/29/operatingSystem/os-concurrency/",
        "description": "并发并发、互斥、同步在实际开发过程中经常会用到，本文将聚焦于互斥与同步，除了了解底层的互斥原理，还将重点学习glic提供的几种互斥机制。
底层原子操作原子操作：将多个步骤合成一个操作，这个操作要么成功，要么失败。底层原子操作由硬件提供，在阅读同步相关的源码时，会经常看到类似atomic_compare_exchange，atomic_fetch_add等类似的函数，其实这些函数就是封装了这些底层的",
        "wordCount": 3845
    }
</script>

</article>

    <section id="comments">
    
        
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>


    
    </section>



                        </div>
                    </section>
                    <aside id="sidebar">
    <a class="sidebar-toggle" title="Expand Sidebar"><i class="toggle icon"></i></a>
    <div class="sidebar-top">
        <p>关注我 :</p>
        <ul class="social-links">
            
                
                <li>
                    <a class="social-tooltip" title="twitter" href="https://github.com/liji53/liji53.github.io" target="_blank" rel="noopener">
                        <i class="icon fa fa-twitter"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="facebook" href="https://github.com/liji53/liji53.github.io" target="_blank" rel="noopener">
                        <i class="icon fa fa-facebook"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="stack-overflow" href="https://github.com/liji53/liji53.github.io" target="_blank" rel="noopener">
                        <i class="icon fa fa-stack-overflow"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="github" href="https://github.com/liji53/liji53.github.io" target="_blank" rel="noopener">
                        <i class="icon fa fa-github"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="weibo" href="https://github.com/liji53/liji53.github.io" target="_blank" rel="noopener">
                        <i class="icon fa fa-weibo"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="rss" href="https://github.com/liji53/liji53.github.io" target="_blank" rel="noopener">
                        <i class="icon fa fa-rss"></i>
                    </a>
                </li>
                
            
        </ul>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/2021/07/05/pythonOther/deployWeb/" id="article-nav-newer" class="article-nav-link-wrap">
        <strong class="article-nav-caption">下一篇</strong>
        <p class="article-nav-title">
        
            花最小的学习成本部署web服务
        
        </p>
        <i class="icon fa fa-chevron-right" id="icon-chevron-right"></i>
    </a>
    
    
        <a href="/2021/06/19/operatingSystem/os-menoryVirtual/" id="article-nav-older" class="article-nav-link-wrap">
        <strong class="article-nav-caption">上一篇</strong>
        <p class="article-nav-title">OS-虚拟memory</p>
        <i class="icon fa fa-chevron-left" id="icon-chevron-left"></i>
        </a>
    
</nav>

    
    <div class="widgets-container">
        
            
                

            
                
    <div class="widget-wrap">
        <h3 class="widget-title">最新文章</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2022/02/23/C++Project/LLVM/" class="thumbnail">
    
    
        <span style="background-image:url(/2022/02/23/C++Project/LLVM/Images/LLVM_vs.png)" alt="LLVM(1)" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2022/02/23/C++Project/LLVM/" class="title">LLVM(1)</a></p>
                            <p class="item-date"><time datetime="2022-02-23T02:11:25.000Z" itemprop="datePublished">2022-02-23</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2022/02/04/C++Basic/atomic/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/C-%E5%9F%BA%E7%A1%80/">C++基础</a></p>
                            <p class="item-title"><a href="/2022/02/04/C++Basic/atomic/" class="title">atomic</a></p>
                            <p class="item-date"><time datetime="2022-02-04T03:24:16.000Z" itemprop="datePublished">2022-02-04</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2022/01/13/C++Project/lexAndYacc/" class="thumbnail">
    
    
        <span style="background-image:url(/2022/01/13/C++Project/lexAndYacc/Images/compiler_flow.png)" alt="利用lex和yacc做代码检查(上)" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2022/01/13/C++Project/lexAndYacc/" class="title">利用lex和yacc做代码检查(上)</a></p>
                            <p class="item-date"><time datetime="2022-01-13T09:15:34.000Z" itemprop="datePublished">2022-01-13</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2022/01/08/C++Basic/smart-ptr/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/C-%E5%9F%BA%E7%A1%80/">C++基础</a></p>
                            <p class="item-title"><a href="/2022/01/08/C++Basic/smart-ptr/" class="title">smart_ptr</a></p>
                            <p class="item-date"><time datetime="2022-01-08T21:48:07.000Z" itemprop="datePublished">2022-01-08</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2021/12/03/pythonOther/regxStudy/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2021/12/03/pythonOther/regxStudy/" class="title">正则表达式入门</a></p>
                            <p class="item-date"><time datetime="2021-12-03T02:22:13.000Z" itemprop="datePublished">2021-12-03</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">分类</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-%E5%9F%BA%E7%A1%80/">C++基础</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python%E6%9D%82%E9%A1%B9/">python杂项</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E8%AF%91%E3%80%81%E6%B1%87%E7%BC%96%E3%80%81%E9%93%BE%E6%8E%A5/">编译、汇编、链接</a><span class="category-list-count">3</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">归档</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a><span class="archive-list-count">1</span></li></ul>
        </div>
    </div>


            
                

            
                

            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">链接</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a>
                    </li>
                
            </ul>
        </div>
    </div>


            
        
    </div>
</aside>

                </div>
            </div>
        </div>
        <footer id="footer">
    <div class="container">
        <div class="container-inner">
            <a id="back-to-top" href="javascript:;"><i class="icon fa fa-angle-up"></i></a>
            <div class="credit">
                <h1 class="logo-wrap">
                    <a href="/" class="logo"></a>
                </h1>
                <p>&copy; 2022 Liji</p>
                
                <p>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="https://github.com/ppoffice" target="_blank">PPOffice</a></p>
                
            </div>
            <div class="footer-plugins">
              
    


            </div>
        </div>
    </div>
</footer>

    </div>
    
    
    <script>
    var disqus_shortname = 'hexo-theme-hueman';
    
    
    var disqus_url = 'https://liji53.github.io/2021/06/29/operatingSystem/os-concurrency/';
    
    (function() {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>





    
        
<script src="/libs/lightgallery/js/lightgallery.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-pager.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-zoom.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-hash.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-share.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-video.min.js"></script>

    
    
        
<script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>

    
    

    
    
    



<!-- Custom Scripts -->

<script src="/js/main.js"></script>


</body>
</html>
