<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />

    

    
    <title>os-并发 | 么么博客</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="keywords" content="" />
    
    <meta name="description" content="并发 底层原子操作 test-and-set compare-and-swap fetch-and-add load 和 store   互斥锁 1.自旋锁 2.nptl互斥锁的实现 3.futex机制 4.nptl读写锁的实现 5.提高并发性能   条件变量 1.用法 2.生产者-消费者模型 3.nptl的实现   信号量 nptl中的实现   并发问题 Non-Deadlock DeadLo">
<meta property="og:type" content="article">
<meta property="og:title" content="os-并发">
<meta property="og:url" content="https://liji53.github.io/2021/06/29/operatingSystem/os-concurrency/index.html">
<meta property="og:site_name" content="么么博客">
<meta property="og:description" content="并发 底层原子操作 test-and-set compare-and-swap fetch-and-add load 和 store   互斥锁 1.自旋锁 2.nptl互斥锁的实现 3.futex机制 4.nptl读写锁的实现 5.提高并发性能   条件变量 1.用法 2.生产者-消费者模型 3.nptl的实现   信号量 nptl中的实现   并发问题 Non-Deadlock DeadLo">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://liji53.github.io/2021/06/29/operatingSystem/os-concurrency/Images/futex_struct.png">
<meta property="article:published_time" content="2021-06-29T15:54:28.000Z">
<meta property="article:modified_time" content="2021-06-29T15:54:28.000Z">
<meta property="article:author" content="Liji">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://liji53.github.io/2021/06/29/operatingSystem/os-concurrency/Images/futex_struct.png">
    

    
        <link rel="alternate" href="https://github.com/liji53/liji53.github.io" title="么么博客" type="application/atom+xml" />
    

    

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/libs/titillium-web/styles.css">

    
<link rel="stylesheet" href="/libs/source-code-pro/styles.css">


    
<link rel="stylesheet" href="/css/style.css">


    
<script src="/libs/jquery/3.5.0/jquery.min.js"></script>

    
    
        
<link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">

    
    
        
<link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">

    
    
    
    


<meta name="generator" content="Hexo 5.4.0"></head>

<body>
    <div id="wrap">
        <header id="header">
    <div id="header-outer" class="outer">
        <div class="container">
            <div class="container-inner">
                <div id="header-title">
                    <h1 class="logo-wrap">
                        <a href="/" class="logo"></a>
                    </h1>
                    
                </div>
                <div id="header-inner" class="nav-container">
                    <a id="main-nav-toggle" class="nav-icon fa fa-bars"></a>
                    <div class="nav-container-inner">
                        <ul id="main-nav">
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/">主页</a>
                                </li>
                            
                                    <ul class="main-nav-list"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/C-%E5%9F%BA%E7%A1%80/">C++基础</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/LLVM/">LLVM</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/python%E6%9D%82%E9%A1%B9/">python杂项</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/%E7%BC%96%E8%AF%91%E3%80%81%E6%B1%87%E7%BC%96%E3%80%81%E9%93%BE%E6%8E%A5/">编译、汇编、链接</a></li></ul>
                                
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/about/index.html">关于</a>
                                </li>
                            
                        </ul>
                        <nav id="sub-nav">
                            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>


</div>
                        </nav>
                    </div>
                </div>
            </div>
        </div>
    </div>
</header>

        <div class="container">
            <div class="main-body container-inner">
                <div class="main-body-inner">
                    <section id="main">
                        <div class="main-body-header">
    <h1 class="header">
    
    <a class="page-title-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
    </h1>
</div>

                        <div class="main-body-content">
                            <article id="post-operatingSystem/os-concurrency" class="article article-single article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
        os-并发
        </h1>
    

            </header>
        
        
            <div class="article-meta">
                
  <div class="article-date">
    <i class="fa fa-calendar"></i>
    <a href="/2021/06/29/operatingSystem/os-concurrency/" class="article-date">
       <time datetime="2021-06-29T15:54:28.000Z" itemprop="datePublished">2021-06-29</time>
    </a>
  </div>


<div class="article-date">
  <i class="fa fa-calendar-plus-o"></i>
  <a href="/2021/06/29/operatingSystem/os-concurrency/" class="article-date">
     <time datetime="2021-06-29T15:54:28.000Z" itemprop="dateModified">2021-06-29</time>
  </a>
</div>


                

                
                

                

            </div>
        
        
        <div class="article-entry" itemprop="articleBody">
            

            

            

            <ul>
<li><a href="#%E5%B9%B6%E5%8F%91">并发</a><ul>
<li><a href="#%E5%BA%95%E5%B1%82%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C">底层原子操作</a><ul>
<li><a href="#test-and-set">test-and-set</a></li>
<li><a href="#compare-and-swap">compare-and-swap</a></li>
<li><a href="#fetch-and-add">fetch-and-add</a></li>
<li><a href="#load-%E5%92%8C-store">load 和 store</a></li>
</ul>
</li>
<li><a href="#%E4%BA%92%E6%96%A5%E9%94%81">互斥锁</a><ul>
<li><a href="#1-%E8%87%AA%E6%97%8B%E9%94%81">1.自旋锁</a></li>
<li><a href="#2-nptl%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0">2.nptl互斥锁的实现</a></li>
<li><a href="#3-futex%E6%9C%BA%E5%88%B6">3.futex机制</a></li>
<li><a href="#4-nptl%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0">4.nptl读写锁的实现</a></li>
<li><a href="#5-%E6%8F%90%E9%AB%98%E5%B9%B6%E5%8F%91%E6%80%A7%E8%83%BD">5.提高并发性能</a></li>
</ul>
</li>
<li><a href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F">条件变量</a><ul>
<li><a href="#1-%E7%94%A8%E6%B3%95">1.用法</a></li>
<li><a href="#2-%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B">2.生产者-消费者模型</a></li>
<li><a href="#3-nptl%E7%9A%84%E5%AE%9E%E7%8E%B0">3.nptl的实现</a></li>
</ul>
</li>
<li><a href="#%E4%BF%A1%E5%8F%B7%E9%87%8F">信号量</a><ul>
<li><a href="#nptl%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0">nptl中的实现</a></li>
</ul>
</li>
<li><a href="#%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98">并发问题</a><ul>
<li><a href="#Non-Deadlock">Non-Deadlock</a></li>
<li><a href="#DeadLock">DeadLock</a></li>
</ul>
</li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B">线程模型</a></li>
<li><a href="#%E8%B5%84%E6%96%99">资料</a></li>
</ul>
</li>
</ul>
<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>在现在的操作系统环境下，进程、线程是并发执行，因此不同的进程、线程之间存在着互相制约的关系，为了协调进程、线程的制约关系，于是有了同步、互斥的概念。<br>先简单过一下相关的概念：<br>同步：线程按照一定的先后顺序来执行<br>互斥：线程不能同时访问有共享资源的代码。<br>原子操作：将多个步骤合成一个操作，这个操作要么成功，要么失败。</p>
<h3 id="底层原子操作"><a href="#底层原子操作" class="headerlink" title="底层原子操作"></a>底层原子操作</h3><p>我们先从底层实现开始说起，要实现临界区的互斥，即可以通过软件方法(感兴趣的可以了解下peterson算法)，也可以通过硬件方法。当然现代的软件系统基本都是靠硬件来实现的，也就是说计算机提供了特殊的机器指令。</p>
<p>在阅读同步、互斥相关的源码时，我们会经常看到类似atomic_compare_exchange，atomic_fetch_add等类似的函数，其实这些函数就是封装了底层的原子指令。因此熟悉底层原子操作对阅读理解pthread等相关的库十分重要。<br>下面我们看下4种基本的原子操作(不是真的实现，只是用代码的方式表述它的功能)</p>
<h5 id="test-and-set"><a href="#test-and-set" class="headerlink" title="test-and-set"></a>test-and-set</h5><p>返回旧值，设置新值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TestAndSet</span><span class="params">(<span class="keyword">int</span> *ptr, <span class="keyword">int</span> <span class="keyword">new</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old = *ptr; <span class="comment">// fetch old value at ptr</span></span><br><span class="line">    *ptr = <span class="keyword">new</span>; <span class="comment">// store ’new’ into ptr</span></span><br><span class="line">    <span class="keyword">return</span> old; <span class="comment">// return the old value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="compare-and-swap"><a href="#compare-and-swap" class="headerlink" title="compare-and-swap"></a>compare-and-swap</h5><p>返回旧值，如果旧值与期望值一致，则设置新值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CompareAndSwap</span><span class="params">(<span class="keyword">int</span> *ptr, <span class="keyword">int</span> expected, <span class="keyword">int</span> <span class="keyword">new</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> actual = *ptr;</span><br><span class="line">    <span class="keyword">if</span> (actual == expected)</span><br><span class="line">        *ptr = <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">return</span> actual;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="fetch-and-add"><a href="#fetch-and-add" class="headerlink" title="fetch-and-add"></a>fetch-and-add</h5><p>返回旧值，更新值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FetchAndAdd</span><span class="params">(<span class="keyword">int</span> *ptr, <span class="keyword">int</span> add_value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old = *ptr;</span><br><span class="line">    *ptr = old + add_value;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用fetch-and-add我们可以实现基于ticket的自旋锁,ticket lock能保证执行顺序，实现先来先拿锁：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">lock_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ticket;</span><br><span class="line">    <span class="keyword">int</span> turn;</span><br><span class="line">&#125; <span class="keyword">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_init</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    lock-&gt;ticket = <span class="number">0</span>;</span><br><span class="line">    lock-&gt;turn = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> myturn = FetchAndAdd(&amp;lock-&gt;ticket, <span class="number">1</span>);   </span><br><span class="line">    <span class="keyword">while</span> (lock-&gt;turn != myturn)  </span><br><span class="line">        ; <span class="comment">// spin</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    FetchAndAdd(&amp;lock-&gt;turn, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="load-和-store"><a href="#load-和-store" class="headerlink" title="load 和 store"></a>load 和 store</h5><p>load指每次读最新的值<br>store如果没有人写ptr则更新ptr，并返回成功，否则返回失败</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LoadLinked</span><span class="params">(<span class="keyword">int</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StoreConditional</span><span class="params">(<span class="keyword">int</span> *ptr, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (如果没有人更新ptr) &#123;</span><br><span class="line">        *ptr = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// success!</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// failed to update</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>了解了硬件提供的几种原子操作之后，我们可以基于这些原子操作实现一些互斥功能。<br>首先来看下互斥锁，但在了解它的实现之前，我们心中需要有一把尺子来衡量锁的优劣，主要从以下2方面考虑：</p>
<ol>
<li>公平性，主要看是否可能存在“饥饿”、“饿死”现象</li>
<li>性能，需要结合实际环境来评估，如cpu是否多核，线程数，临界区的长度等</li>
</ol>
<h5 id="1-自旋锁"><a href="#1-自旋锁" class="headerlink" title="1.自旋锁"></a>1.自旋锁</h5><p>这个实现比较简单，利用前面的4种原子操作都能实现，如利用compare-and-swap：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">lock_t</span> *lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (CompareAndSwap(lock-&gt;flag, <span class="number">0</span>, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        ; <span class="comment">// spin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而它的优劣势也比较明显：<br>从公平性角度来看，无法保证先到先拿锁。<br>从性能角度来看，对于单核cpu来说，采用自旋锁，必然是浪费cpu的，参考<a href="https://liji53.github.io/2021/06/15/operatingSystem/os-virtualization/">虚拟cpu</a>的进程调度<br>但是对于多核的cpu来说，当线程数接近cpu核数，如果临界区很短(立马就释放锁)采用自旋锁，性能将比普通的锁更好(省去了线程切换的开销)</p>
<h5 id="2-nptl互斥锁的实现"><a href="#2-nptl互斥锁的实现" class="headerlink" title="2.nptl互斥锁的实现"></a>2.nptl互斥锁的实现</h5><p>自旋锁会一直占用cpu，浪费资源，如何让出cpu，让程序更高效。下面我们通过glibc的源码，来看下pthread_mutex实现，<br>pthread_mutex_lock的代码(删除了部分代码)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __pthread_mutex_lock (<span class="keyword">pthread_mutex_t</span> *mutex)&#123;</span><br><span class="line">    <span class="comment">// 普通锁</span></span><br><span class="line">    <span class="keyword">if</span> (type == PTHREAD_MUTEX_TIMED_NP)&#123;</span><br><span class="line">        <span class="built_in">LLL_MUTEX_LOCK</span>(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 嵌套锁/递归锁，允许同一个线程多次加锁</span></span><br><span class="line">    <span class="built_in">elif</span> (type == PTHREAD_MUTEX_RECURSIVE_NP)&#123;</span><br><span class="line">        <span class="keyword">pid_t</span> id = <span class="built_in">THREAD_GETMEM</span>(THREAD_SELF, tid);  <span class="comment">// 获取线程id</span></span><br><span class="line">        <span class="keyword">if</span> (mutex-&gt;__data.__owner == id)&#123;<span class="keyword">return</span>;&#125;  <span class="comment">// 已经持有锁直接返回</span></span><br><span class="line">        <span class="built_in">LLL_MUTEX_LOCK</span>(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 适应锁，跟自旋锁类似，尝试获取，但过一段时间仍然获取不到，就放弃，并让出CPU</span></span><br><span class="line">    <span class="built_in">elif</span> (type == PTHREAD_MUTEX_ADAPTIVE_NP)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">LLL_MUTEX_TRYLOCK</span> (mutex) != <span class="number">0</span>)&#123;            </span><br><span class="line">            <span class="keyword">do</span>&#123;  <span class="comment">// 一直尝试获取</span></span><br><span class="line">                <span class="keyword">if</span> (++cnt &gt; max_cnt)&#123;  <span class="comment">// 过一段时间仍然获取不到，则放弃，让出CPU</span></span><br><span class="line">                    <span class="built_in">LLL_MUTEX_LOCK</span>(mutex);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">while</span>(<span class="built_in">LLL_MUTEX_TRYLOCK</span>(mutex) != <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// PTHREAD_MUTEX_ERRORCHECK_NP 检错锁，如果一个线程2次获取同一个锁则，返回失败</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">pid_t</span> id = <span class="built_in">THREAD_GETMEM</span> (THREAD_SELF, tid);</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (mutex-&gt;__data.__owner == id))&#123;<span class="keyword">return</span> EDEADLK;&#125;</span><br><span class="line">        <span class="built_in">LLL_MUTEX_LOCK</span>(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码展示了4种锁的上层实现策略，而最关键的LLL_MUTEX_LOCK的实现，需要我们先知道futex。</p>
<h5 id="3-futex机制"><a href="#3-futex机制" class="headerlink" title="3.futex机制"></a>3.futex机制</h5><p>先简单介绍下futex，futex机制在linux2.5.7之后开始使用(fast Userspace mutexes)。<br>它的主要优势是在加锁的时候根据共享内存里的futex变量，判断该变量是否有竞争，如果没有竞争则通过原子操作把共享的futex变量置1，这样不需要进入内核态，就可以完成加锁了。<br>而如果有竞争则执行系统调用futex_wait，将需要等待的进程(线程)加入到futex的等待队列中，直到通过futex_wake进行唤醒。<br>futex的结构维护在内核中.它的数据结构大概如下：<br><img src="/2021/06/29/operatingSystem/os-concurrency/Images/futex_struct.png"><br>futex把线程加入等待队列以及唤醒的基本接口如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uaddr代表futex word的地址，val代表这个地址期待的值，当*uaddr==val时，才会进行wait</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">futex_wait</span><span class="params">(<span class="keyword">int</span> *uaddr, <span class="keyword">int</span> val)</span></span>;</span><br><span class="line"><span class="comment">// 唤醒n个在uaddr指向的锁变量上挂起等待的进程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">futex_wake</span><span class="params">(<span class="keyword">int</span> *uaddr, <span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<p>好了现在我们可以看LLL_MUTEX_LOCK函数的实现了（参考lowlevellock.h）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LLL_MUTEX_LOCK</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>&#123;</span><br><span class="line">    <span class="comment">// mutex-&gt;__data.__lock 也就是所谓的futex word</span></span><br><span class="line">    <span class="comment">// 对futex word的操作需要原子操作，如果等于0则置为1，表示没有锁竞争</span></span><br><span class="line">    <span class="keyword">if</span>（atomic_compare_and_exchange_bool_acq(mutex-&gt;__data.__lock, <span class="number">0</span>, <span class="number">1</span>)）&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// 有竞争，则阻塞，加入到futex等待队列</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        futex_wait(mutex-&gt;__data.__lock， <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>了解完futex的机制之后，我们再来评估下pthread_mutex的好坏：</p>
<ol>
<li>公平性：通过futex来管理等待线程，并不能保证它绝对的唤醒先后顺序，取决于OS的调度策略。</li>
<li>性能：无竞争时，不需要进程(线程)切换，性能极好；但存在锁冲突时，需要线程切换，存在性能浪费，但好在提供了自适应锁这种兼容spin lock优势的参数</li>
</ol>
<h5 id="4-nptl读写锁的实现"><a href="#4-nptl读写锁的实现" class="headerlink" title="4.nptl读写锁的实现"></a>4.nptl读写锁的实现</h5><p>在读操作频繁，写操作少的情况下，使用读写锁能提高性能，下面我们看下pthread中读写锁的实现(来自glibc-2.35)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">___pthread_rwlock_rdlock (<span class="keyword">pthread_rwlock_t</span> *rwlock)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 原子操作，让reader + 1</span></span><br><span class="line">    r = (atomic_fetch_add_acquire (&amp;rwlock-&gt;__data.__readers,</span><br><span class="line">			    (<span class="number">1</span> &lt;&lt; PTHREAD_RWLOCK_READER_SHIFT)) + (<span class="number">1</span> &lt;&lt; PTHREAD_RWLOCK_READER_SHIFT));</span><br><span class="line">    <span class="comment">// 如果当前为读阶段(即没有写)，则直接返回成功，不阻塞</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_likely ((r &amp; PTHREAD_RWLOCK_WRPHASE) == <span class="number">0</span>))&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="comment">// 如果处于写阶段，但并没有占有锁</span></span><br><span class="line">    <span class="keyword">while</span> ((r &amp; PTHREAD_RWLOCK_WRPHASE) != <span class="number">0</span> &amp;&amp; (r &amp; PTHREAD_RWLOCK_WRLOCKED) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 尝试改成读阶段</span></span><br><span class="line">        <span class="keyword">if</span> (atomic_compare_exchange_weak_acquire (&amp;rwlock-&gt;__data.__readers, &amp;r, r ^ PTHREAD_RWLOCK_WRPHASE))&#123;</span><br><span class="line">            <span class="comment">// 更新写阶段的futex变量，设置为0意味着解锁</span></span><br><span class="line">            <span class="keyword">if</span> ((atomic_exchange_relaxed (&amp;rwlock-&gt;__data.__wrphase_futex, <span class="number">0</span>) &amp; PTHREAD_RWLOCK_FUTEX_USED) != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 唤醒其他阻塞的读线程</span></span><br><span class="line">                <span class="keyword">int</span> <span class="keyword">private</span> = __pthread_rwlock_get_private (rwlock);</span><br><span class="line">                futex_wake (&amp;rwlock-&gt;__data.__wrphase_futex, INT_MAX, <span class="keyword">private</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">// 不停的重新尝试&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 处于写阶段，并且锁已经被其他线程占有</span></span><br><span class="line">        <span class="keyword">while</span> (((wpf = atomic_load_relaxed (&amp;rwlock-&gt;__data.__wrphase_futex))</span><br><span class="line">	            | PTHREAD_RWLOCK_FUTEX_USED) == (<span class="number">1</span> | PTHREAD_RWLOCK_FUTEX_USED))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="keyword">private</span> = __pthread_rwlock_get_private (rwlock);</span><br><span class="line">            <span class="comment">// 如果中途 锁已经释放了</span></span><br><span class="line">            <span class="keyword">if</span> (((wpf &amp; PTHREAD_RWLOCK_FUTEX_USED) == <span class="number">0</span>) &amp;&amp; (!atomic_compare_exchange_weak_relaxed</span><br><span class="line">	                (&amp;rwlock-&gt;__data.__wrphase_futex, &amp;wpf, wpf | PTHREAD_RWLOCK_FUTEX_USED)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 继续尝试，看锁是否又被写进程占有了</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// futex_wait,加入到futex的等待队列</span></span><br><span class="line">            <span class="keyword">int</span> err = __futex_abstimed_wait64 (&amp;rwlock-&gt;__data.__wrphase_futex,</span><br><span class="line">					<span class="number">1</span> | PTHREAD_RWLOCK_FUTEX_USED, clockid, abstime, <span class="keyword">private</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码如果理解有困难，可以参考源码标注的对于各种情况下读写锁的各种状态：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WP 指的是读阶段还是写阶段，WL 指的是写锁， </span></span><br><span class="line"><span class="comment">// R 指的是读的线程数(也代表读锁)， RW 指的是是否有读线程在等待</span></span><br><span class="line">State WP  WL  R   RW  Notes</span><br><span class="line">---------------------------</span><br><span class="line">#<span class="number">1</span>    <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="function">Lock is <span class="title">idle</span> <span class="params">(<span class="keyword">and</span> in a read phase)</span>.</span></span><br><span class="line">#2    0   0   &gt;0  0   Readers have acquired the lock.    </span><br><span class="line">#<span class="number">3</span>    <span class="number">0</span>   <span class="number">1</span>   <span class="number">0</span>   <span class="number">0</span>   Lock is <span class="keyword">not</span> acquired; a writer will <span class="keyword">try</span> to start a</span><br><span class="line">			write phase.                                          </span><br><span class="line">#<span class="number">4</span>    <span class="number">0</span>   <span class="number">1</span>   &gt;<span class="number">0</span>  <span class="number">0</span>   Readers have acquired the lock; a writer is waiting</span><br><span class="line">			<span class="keyword">and</span> <span class="keyword">explicit</span> hand-over to the writer is required. </span><br><span class="line">#<span class="number">4</span>a   <span class="number">0</span>   <span class="number">1</span>   &gt;<span class="number">0</span>  <span class="number">1</span>   Same as #<span class="number">4</span> except that there are further readers</span><br><span class="line">			waiting because the writer is to be preferred.</span><br><span class="line">#<span class="number">5</span>    <span class="number">1</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span>   <span class="function">Lock is <span class="title">idle</span> <span class="params">(<span class="keyword">and</span> in a write phase)</span>.</span></span><br><span class="line">#6    1   0   &gt;0  0   Write phase; readers will try to start a read phase</span><br><span class="line">			(<span class="keyword">requires</span> <span class="keyword">explicit</span> hand-over to all readers that</span><br><span class="line">			<span class="keyword">do</span> <span class="keyword">not</span> start the read phase).</span><br><span class="line">#<span class="number">7</span>    <span class="number">1</span>   <span class="number">1</span>   <span class="number">0</span>   <span class="number">0</span>   Lock is acquired by a writer.</span><br><span class="line">#<span class="number">8</span>    <span class="number">1</span>   <span class="number">1</span>   &gt;<span class="number">0</span>  <span class="number">0</span>   Lock acquired by a writer <span class="keyword">and</span> readers are waiting;</span><br><span class="line">			<span class="keyword">explicit</span> hand-over to the readers is required.</span><br></pre></td></tr></table></figure>
<p><strong>读不占用锁，只有写才占用锁，#3，#4，#4a 这三个阶段 为wrlock加锁的情况，需要等R的个数为0，才能进行写。</strong><br>关于读写锁饿死的情况, 在rdlock源码中并没有看到处理，因此如果写频繁，请不要使用读写锁。<br>最后引用一句话“Big and dumb is better”，无特殊情况，使用普通的锁就可以了。</p>
<h5 id="5-提高并发性能"><a href="#5-提高并发性能" class="headerlink" title="5.提高并发性能"></a>5.提高并发性能</h5><p>这里仅指优化锁的开销，从而提高并发性能<br>从前面的futex机制中，我们知道如果出现锁冲突，就会有进程(线程)切换的开销(上下文切换、进程调度)，因此如何优化锁，核心在于如何减少锁的冲突：</p>
<ol>
<li>减少锁的持有时间，<strong>在锁的过程中不要使用会阻塞的接口</strong>，从时间颗粒度的角度考虑。</li>
<li>减少锁的空间颗粒度，<strong>将临界数据打散，每个分散后的临界数据各使用一把锁，代替全局的锁</strong>。因为数据分散之后，访问某一个数据的概率就减少了，锁冲突也就减少了。</li>
<li>避免使用锁,使用线程本地存储(比方TLS)。思路就是把临界数据变成线程局部数据，一段时间之后再更新回临界数据中。</li>
<li>在读操作频繁，写操作少的数据结构中，使用读写锁;在临界区短，冲突频繁的场景中使用自旋锁。</li>
<li>放弃用锁，使用wait-free的思路，比方使用无锁的数据结构。</li>
</ol>
<p>下面针对第二点，我们看下常见的数据结构如何从空间颗粒度角度，减少锁的开销：</p>
<ol>
<li>双向队列，使用2把锁代替1把锁<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">queue_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">node_t</span> *head;</span><br><span class="line">    <span class="keyword">node_t</span> *tail;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> headLock;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> tailLock;</span><br><span class="line">&#125; <span class="keyword">queue_t</span>;</span><br></pre></td></tr></table></figure></li>
<li>哈希表，每个哈希桶一把锁，哈希值不冲突就不会存在锁冲突<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">hash_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_t</span> lists[BUCKETS];</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> bucketLock[BUCKETS];</span><br><span class="line">&#125; <span class="keyword">hash_t</span>;</span><br></pre></td></tr></table></figure>
针对第三点采用TLS数据，看个多线程计数器的列子：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">counter_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> global; <span class="comment">// global count</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> glock; <span class="comment">// global lock</span></span><br><span class="line">    <span class="keyword">int</span> local[NUMCPUS]; <span class="comment">// 每个线程单独访问，不存在冲突</span></span><br><span class="line">    <span class="keyword">int</span> threshold; <span class="comment">// update frequency</span></span><br><span class="line">&#125; <span class="keyword">counter_t</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">counter_t</span> *c, <span class="keyword">int</span> threadID, <span class="keyword">int</span> amt)</span> </span>&#123;</span><br><span class="line">    c-&gt;local[threadID] += amt; <span class="comment">// assumes amt &gt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;local[threadID] &gt;= c-&gt;threshold) &#123; <span class="comment">// transfer to global</span></span><br><span class="line">        pthread_mutex_lock(&amp;c-&gt;glock);</span><br><span class="line">        c-&gt;global += c-&gt;local[threadID];</span><br><span class="line">        pthread_mutex_unlock(&amp;c-&gt;glock);</span><br><span class="line">        c-&gt;local[threadID] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>条件变量用于线程的同步，保证线程的先后执行顺序</p>
<h5 id="1-用法"><a href="#1-用法" class="headerlink" title="1.用法"></a>1.用法</h5><p>条件变量的使用虽然容易犯错，但它的套路其实比较固定：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景：A线程先执行，再执行B线程</span></span><br><span class="line"><span class="comment">// A线程：</span></span><br><span class="line">Pthread_mutex_lock(&amp;m);</span><br><span class="line">设置条件</span><br><span class="line">Pthread_cond_signal(&amp;c);</span><br><span class="line">Pthread_mutex_unlock(&amp;m);</span><br><span class="line"><span class="comment">// B线程：</span></span><br><span class="line">Pthread_mutex_lock(&amp;mutex); </span><br><span class="line"><span class="keyword">while</span> (条件不满足) </span><br><span class="line">    Pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">Pthread_mutex_unlock(&amp;mutex); </span><br></pre></td></tr></table></figure>
<p>常见的错误就是：</p>
<ol>
<li>没有和锁一起配合使用，或者锁顺序有问题，牢记条件变量要传锁的原因，即<strong>Pthread_cond_wait内部实现： 1.先释放锁，2.加入等待队列，3.唤醒之后再加锁</strong></li>
<li>Pthread_cond_wait<strong>在等待条件满足时，要用while 不要用if</strong>， Pthread_cond_wait可能存在虚假唤醒(被信号中断唤醒);也有可能同时唤醒2个线程，但另一个线程执行很快，又把值改回去了(ABA)</li>
<li>该使用2个条件变量，却只使用了一个条件变量，参考下面的消费者-生产者的错误案例：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread__cond_t</span> cond;</span><br><span class="line"><span class="keyword">pthread__mutex_t</span> mutex;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        Pthread_mutex_lock(&amp;mutex); <span class="comment">// p1</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">1</span>) <span class="comment">// p2</span></span><br><span class="line">            Pthread_cond_wait(&amp;cond, &amp;mutex); <span class="comment">// p3</span></span><br><span class="line">        put(i); <span class="comment">// p4</span></span><br><span class="line">        Pthread_cond_signal(&amp;cond); <span class="comment">// p5</span></span><br><span class="line">        Pthread_mutex_unlock(&amp;mutex); <span class="comment">// p6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        Pthread_mutex_lock(&amp;mutex); <span class="comment">// c1</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) <span class="comment">// c2</span></span><br><span class="line">            Pthread_cond_wait(&amp;cond, &amp;mutex); <span class="comment">// c3</span></span><br><span class="line">        <span class="keyword">int</span> tmp = get(); <span class="comment">// c4</span></span><br><span class="line">        Pthread_cond_signal(&amp;cond); <span class="comment">// c5</span></span><br><span class="line">        Pthread_mutex_unlock(&amp;mutex); <span class="comment">// c6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这一段代码，如果只有1个消费者和1个生产者没有问题，但如果consumer(消费者)的线程数是2个就有问题了。<br>错误原因：如果consumer1 发出signal ，但唤醒的不是producer，而是consumer2，consumer2由于条件不满足，又睡眠了（并没有发signal），这时候三个线程就将永远睡眠。</li>
</ol>
<h5 id="2-生产者-消费者模型"><a href="#2-生产者-消费者模型" class="headerlink" title="2.生产者-消费者模型"></a>2.生产者-消费者模型</h5><p>作为线程同步的最经典的例子，其实真的有必要再三review。<br>该模型正确的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cond_t</span> empty, fill;</span><br><span class="line"><span class="keyword">mutex_t</span> mutex;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        Pthread_mutex_lock(&amp;mutex); <span class="comment">// p1</span></span><br><span class="line">        <span class="keyword">while</span> (count == MAX) <span class="comment">// p2</span></span><br><span class="line">            Pthread_cond_wait(&amp;empty, &amp;mutex); <span class="comment">// p3</span></span><br><span class="line">        put(i); <span class="comment">// p4</span></span><br><span class="line">        Pthread_cond_signal(&amp;fill); <span class="comment">// p5</span></span><br><span class="line">        Pthread_mutex_unlock(&amp;mutex); <span class="comment">// p6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        Pthread_mutex_lock(&amp;mutex); <span class="comment">// c1</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) <span class="comment">// c2</span></span><br><span class="line">            Pthread_cond_wait(&amp;fill, &amp;mutex); <span class="comment">// c3</span></span><br><span class="line">        <span class="keyword">int</span> tmp = get(); <span class="comment">// c4</span></span><br><span class="line">        Pthread_cond_signal(&amp;empty); <span class="comment">// c5</span></span><br><span class="line">        Pthread_mutex_unlock(&amp;mutex); <span class="comment">// c6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-nptl的实现"><a href="#3-nptl的实现" class="headerlink" title="3.nptl的实现"></a>3.nptl的实现</h5><p>pthread_cond_wait的实现（来自glibc-2.35）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __pthread_cond_wait(<span class="keyword">pthread_cond_t</span> *cond, <span class="keyword">pthread_mutex_t</span> *mutex)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// wseq低位是group的索引，因此需要加2才表示seq加1</span></span><br><span class="line">    <span class="keyword">uint64_t</span> wseq = __condvar_fetch_add_wseq_acquire (cond, <span class="number">2</span>);  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> g = wseq &amp; <span class="number">1</span>;  <span class="comment">// g是group[1]的索引</span></span><br><span class="line">    <span class="keyword">uint64_t</span> seq = wseq &gt;&gt; <span class="number">1</span>;   <span class="comment">// seq 为序列号</span></span><br><span class="line">    <span class="comment">// __wrefs 低3位有其他用处，+8 表示等待者计数 +1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags = atomic_fetch_add_relaxed (&amp;cond-&gt;__data.__wrefs, <span class="number">8</span>);</span><br><span class="line">    <span class="comment">// 【用户锁，解锁】</span></span><br><span class="line">    err = __pthread_mutex_unlock_usercnt (mutex, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 需要唤醒的等待者个数，__g_signals + g表示当前group</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> signals = atomic_load_acquire (cond-&gt;__data.__g_signals + g);</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果有信号</span></span><br><span class="line">            <span class="keyword">if</span> (signals != <span class="number">0</span>) &#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="comment">// __g_refs 当前组的引用计数+1</span></span><br><span class="line">            atomic_fetch_add_acquire (cond-&gt;__data.__g_refs + g, <span class="number">2</span>);</span><br><span class="line">            <span class="comment">// 【futex_wait 加入等待队列，阻塞】</span></span><br><span class="line">            err = __futex_abstimed_wait_cancelable64 (cond-&gt;__data.__g_signals + g, <span class="number">0</span>, clockid, abstime, <span class="keyword">private</span>);</span><br><span class="line">            <span class="comment">// 重新加载信号个数，被唤醒之后，signal有变化</span></span><br><span class="line">            signals = atomic_load_acquire (cond-&gt;__data.__g_signals + g);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前有需要唤醒的等待者，尝试获取signal</span></span><br><span class="line">    <span class="keyword">while</span> (!atomic_compare_exchange_weak_acquire (cond-&gt;__data.__g_signals + g, &amp;signals, signals - <span class="number">2</span>));</span><br><span class="line">    <span class="comment">// 当前group的起始序列号</span></span><br><span class="line">    <span class="keyword">uint64_t</span> g1_start = __condvar_load_g1_start_relaxed (cond);</span><br><span class="line">    <span class="comment">// 优先消费之前被wait的等待者，而不是本次的等待者</span></span><br><span class="line">    <span class="keyword">if</span> (seq &lt; (g1_start &gt;&gt; <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span> (((g1_start &amp; <span class="number">1</span>) ^ <span class="number">1</span>) == g)&#123;</span><br><span class="line">            <span class="comment">// 再次更新信号量</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> s = atomic_load_relaxed (cond-&gt;__data.__g_signals + g);</span><br><span class="line">            <span class="keyword">while</span> (__condvar_load_g1_start_relaxed (cond) == g1_start)&#123;</span><br><span class="line">                <span class="keyword">if</span> (((s &amp; <span class="number">1</span>) != <span class="number">0</span>) || atomic_compare_exchange_weak_relaxed(cond-&gt;__data.__g_signals + g, &amp;s, s + <span class="number">2</span>))&#123;</span><br><span class="line">                    <span class="comment">// 优先唤醒其他等待者</span></span><br><span class="line">                    futex_wake (cond-&gt;__data.__g_signals + g, <span class="number">1</span>, <span class="keyword">private</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">done:</span><br><span class="line">    <span class="comment">// 【用户锁，加锁】</span></span><br><span class="line">    err = __pthread_mutex_cond_lock (mutex);</span><br><span class="line">    <span class="keyword">return</span> (err != <span class="number">0</span>) ? err : result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码把异常处理、group的处理等都给省去了，即使如此，阅读这个代码可能依然有困难。<br>建议去glibc阅读源码（里面的注释很详细），搞清楚pthread_cond_t的每个字段的含义之后，阅读就轻松多了。<br>其实我们简化成以下伪代码就好理解了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_wait(<span class="keyword">cond_t</span>* t, <span class="keyword">mutex_t</span>* m)&#123;</span><br><span class="line">    unlock(m);</span><br><span class="line">    <span class="keyword">if</span>(atomic_load(t-&gt;futex_signal) == <span class="number">0</span>)&#123; <span class="comment">//如果signal为0，则进入等待队列</span></span><br><span class="line">        futex_wait(t-&gt;futex_signal, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    lock(m);</span><br><span class="line">&#125;</span><br><span class="line">pthread_cond_signal(<span class="keyword">cond_t</span>* t)&#123;</span><br><span class="line">    atmoic_ftech_and_add(t-&gt;futex_signal，<span class="number">1</span>);  <span class="comment">// signal 原子加1</span></span><br><span class="line">    futex_wake(t-&gt;futex_var, <span class="number">1</span>);  <span class="comment">// 唤醒一个等待者</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><h5 id="nptl中的实现"><a href="#nptl中的实现" class="headerlink" title="nptl中的实现"></a>nptl中的实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __new_sem_post (<span class="keyword">sem_t</span> *sem)&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> v = atomic_load_relaxed (&amp;isem-&gt;value);</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="comment">// 溢出</span></span><br><span class="line">        <span class="keyword">if</span> ((v &gt;&gt; SEM_VALUE_SHIFT) == SEM_VALUE_MAX)&#123;</span><br><span class="line">	        __set_errno (EOVERFLOW);</span><br><span class="line">	        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">/// 原子+1，如果有其他post导致value变换，则循环尝试</span></span><br><span class="line">    <span class="keyword">while</span> (!atomic_compare_exchange_weak_release(&amp;isem-&gt;value, &amp;v, v + (<span class="number">1</span> &lt;&lt; SEM_VALUE_SHIFT)));</span><br><span class="line">    <span class="comment">// 如果有等待的线程，则唤醒一个线程</span></span><br><span class="line">    <span class="keyword">if</span> ((v &amp; SEM_NWAITERS_MASK) != <span class="number">0</span>)</span><br><span class="line">        futex_wake (&amp;isem-&gt;value, <span class="number">1</span>, <span class="keyword">private</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>信号量的源码实现比读写锁、条件变量好理解多了，其实基本上就是对futex封装了一下。</p>
<h3 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h3><p>在多线程项目的开发过程中，我们首先要确认有哪些线程、这些线程的执行顺序是怎么样的、哪些是临界资源，然后才能通过互斥、同步来解决这些问题。<br>很多人可能错误的认为并发问题是指死锁问题，但其实在实际软件项目中，没有考虑前者导致的问题(非死锁导致的问题)比死锁导致的问题更多。</p>
<h5 id="Non-Deadlock"><a href="#Non-Deadlock" class="headerlink" title="Non-Deadlock"></a>Non-Deadlock</h5><p>下面我们看看，因为我们的不重视而导致的常见的两种非死锁并发问题：</p>
<ol>
<li>违背原子性：简单来说就是对于临界数据没有加锁</li>
<li>违背执行顺序：在多线程中由于执行顺序不正确导致的问题，需要通过条件变量、信号量来保证同步</li>
</ol>
<p>这类问题看起来很简单，但解决起来却非常困难，因为不像死锁，你能肉眼看到问题发生，而这类问题你需要对代码很深入的理解才能解决。同时这类问题还具有很强的隐藏性，偶然性。</p>
<h5 id="DeadLock"><a href="#DeadLock" class="headerlink" title="DeadLock"></a>DeadLock</h5><p>死锁产生的条件与解决方案：</p>
<ol>
<li>互斥：资源是独占的且排他使用<br>解决（实现复杂）：不使用互斥锁，而采用wait-free的方案。</li>
<li>请求和保持：进程每次申请它所需要的一部分资源，在申请新的资源的同时，继续占用已分配到的资源。<br>解决（会导致性能差）：在线程获取多个锁之前，先加一把大范围的锁。</li>
<li>不可剥夺：进程所获得的资源在未使用完毕之前，不被其他进程强行剥夺，而只能由获得该资源的进程资源释放。<br>解决（可读性差，异常处理复杂）：使用trylock，尝试获取锁，如果获取锁失败，则释放已经占用的锁，从而让其他进程能获取锁，但释放锁的时候需要考虑资源释放与重新申请的问题。</li>
<li>循环等待：比方A进程占用a锁，同时请求b锁，B进程占用b锁，请求a锁，导致AB进程互相等待<br>解决（比较常用的方法）：保持获取锁的顺序一致性。</li>
</ol>
<p>介绍完死锁的原因以及解决方案之后，我们还是不能杜绝死锁的产生，究其原因，一是因为软件的复杂度很高(组件之间的互相依赖、接口的封装等)，二是所谓的解决方案无法通过技术手段实现。<br>因此从死锁预防的角度来看：</p>
<ol>
<li>要从提升软件质量上下手，比如适当的接口使用说明、代码评审、测试覆盖以及代码漏洞检测等。</li>
<li>降低软件复杂度，及时对耦合度高、难以理解的模块进行重构。</li>
</ol>
<h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p>下面我们了解下在《Modern Operating Systems》中提到的线程模型：<br><img src="/2021/06/29/operatingSystem/os-concurrency/Images/thread_module.png"><br>在linux的pthread库中采用的是1对1的线程模型，即一个用户对应一个内核线程，内核负责每个线程的调度，这种一对一的模型存在用户态/内核态切换频繁的问题。<br>因此为提升效率，由用户层实现支持多对一的定时器模型，能提高一定的效率，但这种模型调度的任务不能阻塞，否则会导致其他任务也不能执行。</p>
<p>最后，我们简单总结下进程与线程的区别：<br>进程是资源分配(除cpu)的基本单位，线程是CPU调度的基本单位。线程有独立的线程栈、寄存器。</p>
<h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><p>书籍：<br>《Operating Systems: Three Easy Pieces》(<a target="_blank" rel="noopener" href="https://pages.cs.wisc.edu/~remzi/OSTEP/">线上书籍</a>)<br>《Modern Operating Systems》（第四版：有介绍futex,线程模型）<br>glibc源码地址：<br><a target="_blank" rel="noopener" href="http://ftp.gnu.org/gnu/glibc/">http://ftp.gnu.org/gnu/glibc/</a></p>

        </div>
        <footer class="article-footer">
            



    <a data-url="https://liji53.github.io/2021/06/29/operatingSystem/os-concurrency/" data-id="cl1zz9qep00011en47f1c6jl2" class="article-share-link"><i class="fa fa-share"></i>分享到</a>
<script>
    (function ($) {
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "author": {
            "@type": "Person",
            "name": "Liji"
        },
        "headline": "os-并发",
        "image": "https://liji53.github.io/2021/06/29/operatingSystem/os-concurrency/Images/futex_struct.png",
        "keywords": "",
        "genre": "操作系统",
        "datePublished": "2021-06-29",
        "dateCreated": "2021-06-29",
        "dateModified": "2021-06-29",
        "url": "https://liji53.github.io/2021/06/29/operatingSystem/os-concurrency/",
        "description": "
并发
底层原子操作
test-and-set
compare-and-swap
fetch-and-add
load 和 store


互斥锁
1.自旋锁
2.nptl互斥锁的实现
3.futex机制
4.nptl读写锁的实现
5.提高并发性能


条件变量
1.用法
2.生产者-消费者模型
3.nptl的实现


信号量
nptl中的实现


并发问题
Non-Deadlock
DeadLo",
        "wordCount": 3839
    }
</script>

</article>

    <section id="comments">
    
        
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>


    
    </section>



                        </div>
                    </section>
                    <aside id="sidebar">
    <a class="sidebar-toggle" title="Expand Sidebar"><i class="toggle icon"></i></a>
    <div class="sidebar-top">
        <p>关注我 :</p>
        <ul class="social-links">
            
                
                <li>
                    <a class="social-tooltip" title="twitter" href="https://github.com/liji53/liji53.github.io" target="_blank" rel="noopener">
                        <i class="icon fa fa-twitter"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="facebook" href="https://github.com/liji53/liji53.github.io" target="_blank" rel="noopener">
                        <i class="icon fa fa-facebook"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="stack-overflow" href="https://github.com/liji53/liji53.github.io" target="_blank" rel="noopener">
                        <i class="icon fa fa-stack-overflow"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="github" href="https://github.com/liji53/liji53.github.io" target="_blank" rel="noopener">
                        <i class="icon fa fa-github"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="weibo" href="https://github.com/liji53/liji53.github.io" target="_blank" rel="noopener">
                        <i class="icon fa fa-weibo"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="rss" href="https://github.com/liji53/liji53.github.io" target="_blank" rel="noopener">
                        <i class="icon fa fa-rss"></i>
                    </a>
                </li>
                
            
        </ul>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/2021/07/05/pythonOther/deployWeb/" id="article-nav-newer" class="article-nav-link-wrap">
        <strong class="article-nav-caption">下一篇</strong>
        <p class="article-nav-title">
        
            花最小的学习成本部署web服务
        
        </p>
        <i class="icon fa fa-chevron-right" id="icon-chevron-right"></i>
    </a>
    
    
        <a href="/2021/06/19/operatingSystem/os-menoryVirtual/" id="article-nav-older" class="article-nav-link-wrap">
        <strong class="article-nav-caption">上一篇</strong>
        <p class="article-nav-title">OS-虚拟memory</p>
        <i class="icon fa fa-chevron-left" id="icon-chevron-left"></i>
        </a>
    
</nav>

    
    <div class="widgets-container">
        
            
                

            
                
    <div class="widget-wrap">
        <h3 class="widget-title">最新文章</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2022/07/27/LLVM/llvm-arrayParamAssign/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/LLVM/">LLVM</a></p>
                            <p class="item-title"><a href="/2022/07/27/LLVM/llvm-arrayParamAssign/" class="title">【Clang Static Analyzer】数组参数赋值(原创)</a></p>
                            <p class="item-date"><time datetime="2022-07-27T19:20:31.000Z" itemprop="datePublished">2022-07-27</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2022/07/02/LLVM/llvm-floatCmpZero/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/LLVM/">LLVM</a></p>
                            <p class="item-title"><a href="/2022/07/02/LLVM/llvm-floatCmpZero/" class="title">【Clang Static Analyzer】浮点变量与零比较检查(原创)</a></p>
                            <p class="item-date"><time datetime="2022-07-02T09:19:31.000Z" itemprop="datePublished">2022-07-02</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2022/06/11/LLVM/llvm-PathChecker/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/LLVM/">LLVM</a></p>
                            <p class="item-title"><a href="/2022/06/11/LLVM/llvm-PathChecker/" class="title">【Clang Static Analyzer】基于Exploded Graph的检查</a></p>
                            <p class="item-date"><time datetime="2022-06-11T20:45:01.000Z" itemprop="datePublished">2022-06-11</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2022/05/25/cryptograghy/cryptography-tls/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2022/05/25/cryptograghy/cryptography-tls/" class="title">cryptography-tls</a></p>
                            <p class="item-date"><time datetime="2022-05-25T08:42:21.000Z" itemprop="datePublished">2022-05-25</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2022/05/23/network/net-ip/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2022/05/23/network/net-ip/" class="title">net-ip</a></p>
                            <p class="item-date"><time datetime="2022-05-23T06:28:48.000Z" itemprop="datePublished">2022-05-23</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">分类</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-%E5%9F%BA%E7%A1%80/">C++基础</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/LLVM/">LLVM</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python%E6%9D%82%E9%A1%B9/">python杂项</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E8%AF%91%E3%80%81%E6%B1%87%E7%BC%96%E3%80%81%E9%93%BE%E6%8E%A5/">编译、汇编、链接</a><span class="category-list-count">3</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">归档</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a><span class="archive-list-count">1</span></li></ul>
        </div>
    </div>


            
                

            
                

            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">链接</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a>
                    </li>
                
            </ul>
        </div>
    </div>


            
        
    </div>
</aside>

                </div>
            </div>
        </div>
        <footer id="footer">
    <div class="container">
        <div class="container-inner">
            <a id="back-to-top" href="javascript:;"><i class="icon fa fa-angle-up"></i></a>
            <div class="credit">
                <h1 class="logo-wrap">
                    <a href="/" class="logo"></a>
                </h1>
                <p>&copy; 2022 Liji</p>
                
                <p>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="https://github.com/ppoffice" target="_blank">PPOffice</a></p>
                
            </div>
            <div class="footer-plugins">
              
    


            </div>
        </div>
    </div>
</footer>

    </div>
    
    
    <script>
    var disqus_shortname = 'hexo-theme-hueman';
    
    
    var disqus_url = 'https://liji53.github.io/2021/06/29/operatingSystem/os-concurrency/';
    
    (function() {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>





    
        
<script src="/libs/lightgallery/js/lightgallery.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-pager.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-zoom.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-hash.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-share.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-video.min.js"></script>

    
    
        
<script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>

    
    

    
    
    



<!-- Custom Scripts -->

<script src="/js/main.js"></script>


</body>
</html>
